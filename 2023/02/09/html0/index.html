<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>前端系列问题 | 五星码农</title>
  
  <meta name="author" content="孑孓">
  
  <meta name="description" content="IT技术 Vue  Hexo 前端 个人博客 干货 百科知识">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:title" content="前端系列问题" />
  <meta property="og:site_name" content="五星码农" />

  
  <meta property="og:image" content="" />
  

  

  
  <!-- <link href="/favicon.png" rel="icon"> -->
  <link rel="shortcut icon"  href="/img/favicon.ico" style="border-radius: 50%;">
  

  <!-- CSS 这个css即_config.yml 下的theme 这里是：cerulean -->
  <!-- <link rel="stylesheet" href="/css/themes/Freemind.css" media="screen" type="text/css"> -->




  <link rel="stylesheet" href="/css/highlight-default.min.css" media="screen" type="text/css">

  <link rel="stylesheet" href="/css/comment.css" media="screen" type="text/css">

  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/self-style.css" media="screen" type="text/css">


  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.9/es5-shim.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.7/es5-sham.min.js"></script>
  <![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>
  
  <!-- analytics -->
  



<meta name="generator" content="Hexo 6.3.0"></head>
<body>
  <nav id="main-nav" class="navbar navbar-inverse navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
	<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
       <a class="navbar-brand" href="/">五星码农</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="所有发表记录">
			  <i class="fa fa-archive"></i>档案
			</a>
		  </li>
		  
		  <li>
			<a href="/note" title="我的速记">
			  <i class="fa fa-user"></i>速记
			</a>
		  </li>
		  
		  <li>
			<a href="/mark" title="mark清单">
			  <i class="fa fa-list-ol"></i>mark清单
			</a>
		  </li>
		  
		  <li>
			<a href="/message" title="messagebord">
			  <i class="fa fa-book"></i>访客留言
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="关于我">
			  <i class="fa fa-user"></i>关于
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
    <div class="content">
      


	
		<div class="page-header page-header-inverse ">		
			<h1 class="title title-inverse "> 前端系列问题</h1>
		</div>		
	






<div class="row post">
	<!-- cols -->
	
	<div id="top_meta"></div>
	<div class="col-md-9">
	

	<!-- content -->
	<div class="mypage">		
	  		

	  <h3 id="typescript跟es6有什么区别？"><a href="#typescript跟es6有什么区别？" class="headerlink" title="typescript跟es6有什么区别？"></a>typescript跟es6有什么区别？</h3><h3 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h3><p>TypeScript是一种由微软开发的自由和开源的编程语言。它是JavaScript的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。</p>
<p>TypeScript扩展了JavaScript的语法，所以任何现有的JavaScript程序可以不加改变的在TypeScript下工作。TypeScript是为大型应用之开发而设计，而编译时它产生 JavaScript 以确保兼容性。</p>
<p>TypeScript 支持为已存在的 JavaScript 库添加类型信息的头文件，扩展了它对于流行的库如 jQuery，MongoDB，Node.js和 D3.js 的好处。</p>
<p>TypeScript 的历史</p>
<p>Anders Hejlsberg开发了 TypeScript。它于2012 年 10 月 1 日首次向公众推出。经过微软内部两年的开发，2013 年发布了新版 TypeScript 0.9。2019 年 4 月 24 日发布了TypeScript 3.4.5。</p>
<span id="more"></span>

<h3 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h3><p>ECMAScript (ES) 是由ECMA 国际标准化的脚本语言规范。它的创建是为了标准化 JavaScript。ES 脚本语言包含许多实现，其中最流行的是JavaScript。开发人员主要将ECMAScript用于万维网 (WWW)的客户端脚本。</p>
<p>ECMAScript 标准的第六版是 ECMAScript6 或 ES6，后来更名为ECMAScript 2015。它是对 JavaScript 语言的重大增强，它允许我们为复杂的应用程序编写程序。它添加了许多旨在简化大规模软件开发的功能。最常见的 ES6 网络浏览器是Chrome和Firefox。转译器将基于 ES6 的代码转换为支持许多浏览器的ES5 。TypeScript 是一个转译器。Grunt、Gulp 和 Babel 是编译模块的其他一些转译器。因此，TypeScript 支持 ES6。</p>
<p>历史</p>
<p>JavaScript 于 1995 年5 月由Brendan Eich引入。它最初被称为Mocha，由Netscape创始人Marc Andreessen选择，后来更名为LiveScript。与此同时，Sun Microsystems拥有 JavaScript 的商标。1995年12 月，Netscape 获得了商标许可，并将其更名为 JavaScript。</p>
<p>在1996 年到1997 年间，Netscape 将 JavaScript 带到了 ECMA 标准组织，以维护该语言的规范。1997年6 月，创建了 ECMA 技术委员会 39 (TC39) 以继续发展该语言，最终发布了ECMA-262 Ed.1。</p>
<p>JavaScript 的第一个标准版本是 ECMAScript 1，于 1997 年6 月发布。一年后，ECMAScript 2 发布了，它只包含了一些小的更改，以保持 JavaScript 的并行 ISO 标准。1999年12 月，ECMAScript 3 发布，引入了 JavaScript 的很多流行特性。2009年12 月，ECMAScript 或 ES6 发布，随后更名为 ECMAScript 2015。</p>
<h3 id="TypeScript和ES6的区别"><a href="#TypeScript和ES6的区别" class="headerlink" title="TypeScript和ES6的区别"></a>TypeScript和ES6的区别</h3><blockquote><p>1、原始数据类型</p>
<p>TypeScript支持所有原始数据类型，ES6不支持所有数据类型。</p>
<p>2、变量作用域</p>
<p>TypeScript有3个作用域：全局作用域、类作用域、局部作用域。</p>
<p>ES6有2个作用域：全局作用域、局部作用域。</p>
<p>3、模块</p>
<p>在TypeScript中，模块有两种类型：内部和外部模块</p>
<p>在ES6中，模块分为导入模块和导出模块。</p>
</blockquote>



<h2 id="HTML-篇"><a href="#HTML-篇" class="headerlink" title="HTML 篇"></a>HTML 篇</h2><h3 id="简述一下你对-HTML-语义化的理解？"><a href="#简述一下你对-HTML-语义化的理解？" class="headerlink" title="简述一下你对 HTML 语义化的理解？"></a>简述一下你对 HTML 语义化的理解？</h3><p>用正确的标签做正确的事情。<br>html 语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析；即使在没有样式 CSS 情况下也以一种文档格式显示，并且是容易阅读的;<br>搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO;<br>使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</p>
<h3 id="标签上-title-与-alt-属性的区别是什么？"><a href="#标签上-title-与-alt-属性的区别是什么？" class="headerlink" title="标签上 title 与 alt 属性的区别是什么？"></a>标签上 title 与 alt 属性的区别是什么？</h3><p>alt 是给搜索引擎识别，在图像无法显示时的替代文本；<br>title 是关于元素的注释信息，主要是给用户解读。<br>当鼠标放到文字或是图片上时有 title 文字显示。（因为 IE 不标准）在 IE 浏览器中 alt 起到了 title 的作用，变成文字提示。<br>在定义 img 对象时，将 alt 和 title 属性写全，可以保证在各种浏览器中都能正常使用。</p>
<h3 id="iframe的优缺点？"><a href="#iframe的优缺点？" class="headerlink" title="iframe的优缺点？"></a>iframe的优缺点？</h3><p>优点：</p>
<p>解决加载缓慢的第三方内容如图标和广告等的加载问题<br>Security sandbox<br>并行加载脚本<br>缺点：</p>
<p>iframe会阻塞主页面的Onload事件<br>即时内容为空，加载也需要时间<br>没有语意</p>
<h3 id="href-与-src？"><a href="#href-与-src？" class="headerlink" title="href 与 src？"></a>href 与 src？</h3><p>href (Hypertext Reference)指定网络资源的位置，从而在当前元素或者当前文档和由当前属性定义的需要的锚点或资源之间定义一个链接或者关系。（目的不是为了引用资源，而是为了建立联系，让当前标签能够链接到目标地址。）<br>src source（缩写），指向外部资源的位置，指向的内容将会应用到文档中当前标签所在位置。<br>href与src的区别<br>1、请求资源类型不同：href 指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的联系。在请求 src 资源时会将其指向的资源下载并应用到文档中，比如 JavaScript 脚本，img 图片；<br>2、作用结果不同：href 用于在当前文档和引用资源之间确立联系；src 用于替换当前内容；<br>3、浏览器解析方式不同：当浏览器解析到src ，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等也如此，类似于将所指向资源应用到当前内容。这也是为什么建议把 js 脚本放在底部而不是头部的原因。</p>
<h2 id="CSS-篇"><a href="#CSS-篇" class="headerlink" title="CSS 篇"></a>CSS 篇</h2><h3 id="介绍一下-CSS-的盒子模型？"><a href="#介绍一下-CSS-的盒子模型？" class="headerlink" title="介绍一下 CSS 的盒子模型？"></a>介绍一下 CSS 的盒子模型？</h3><p>有两种， IE 盒子模型、W3C 盒子模型；<br>盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；<br>区 别： IE 的 content 部分把 border 和 padding 计算了进去;</p>
<h3 id="css-选择器优先级？"><a href="#css-选择器优先级？" class="headerlink" title="css 选择器优先级？"></a>css 选择器优先级？</h3><p>!important &gt; 行内样式（比重1000）&gt; ID 选择器（比重100） &gt; 类选择器（比重10） &gt; 标签（比重1） &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性</p>
<h3 id="垂直居中几种方式？"><a href="#垂直居中几种方式？" class="headerlink" title="垂直居中几种方式？"></a>垂直居中几种方式？</h3><p>单行文本: line-height &#x3D; height<br>图片: vertical-align: middle;<br>absolute 定位: top: 50%;left: 50%;transform: translate(-50%, -50%);<br>flex: display:flex;margin:auto</p>
<h3 id="简明说一下-CSS-link-与-import-的区别和用法？"><a href="#简明说一下-CSS-link-与-import-的区别和用法？" class="headerlink" title="简明说一下 CSS link 与 @import 的区别和用法？"></a>简明说一下 CSS link 与 @import 的区别和用法？</h3><p>link 是 XHTML 标签，除了加载CSS外，还可以定义 RSS 等其他事务；@import 属于 CSS 范畴，只能加载 CSS。<br>link 引用 CSS 时，在页面载入时同时加载；@import 需要页面网页完全载入以后加载。<br>link 是 XHTML 标签，无兼容问题；@import 是在 CSS2.1 提出的，低版本的浏览器不支持。<br>link 支持使用 Javascript 控制 DOM 去改变样式；而@import不支持。</p>
<h3 id="rgba和opacity的透明效果有什么不同？"><a href="#rgba和opacity的透明效果有什么不同？" class="headerlink" title="rgba和opacity的透明效果有什么不同？"></a>rgba和opacity的透明效果有什么不同？</h3><p>opacity 会继承父元素的 opacity 属性，而 RGBA 设置的元素的后代元素不会继承不透明属性。</p>
<h3 id="display-none和visibility-hidden的区别？"><a href="#display-none和visibility-hidden的区别？" class="headerlink" title="display:none和visibility:hidden的区别？"></a>display:none和visibility:hidden的区别？</h3><p>display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。<br>visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。</p>
<h3 id="position的值，-relative和absolute分别是相对于谁进行定位的？"><a href="#position的值，-relative和absolute分别是相对于谁进行定位的？" class="headerlink" title="position的值， relative和absolute分别是相对于谁进行定位的？"></a>position的值， relative和absolute分别是相对于谁进行定位的？</h3><p>relative:相对定位，相对于自己本身在正常文档流中的位置进行定位。<br>absolute:生成绝对定位，相对于最近一级定位不为static的父元素进行定位。<br>fixed: （老版本IE不支持）生成绝对定位，相对于浏览器窗口或者frame进行定位。<br>static:默认值，没有定位，元素出现在正常的文档流中。<br>sticky:生成粘性定位的元素，容器的位置根据正常文档流计算得出。</p>
<h3 id="画一条0-5px的直线？"><a href="#画一条0-5px的直线？" class="headerlink" title="画一条0.5px的直线？"></a>画一条0.5px的直线？</h3><p>考查的是css3的transform</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">height: 1px;</span><br><span class="line">transform: scale(0.5);</span><br></pre></td></tr></table></figure>
<h3 id="calc-support-media各自的含义及用法？"><a href="#calc-support-media各自的含义及用法？" class="headerlink" title="calc, support, media各自的含义及用法？"></a>calc, support, media各自的含义及用法？</h3><p>@support 主要是用于检测浏览器是否支持CSS的某个属性，其实就是条件判断，如果支持某个属性，你可以写一套样式，如果不支持某个属性，你也可以提供另外一套样式作为替补。<br>calc() 函数用于动态计算长度值。 calc()函数支持 “+”, “-”, “*”, “&#x2F;” 运算；<br>@media 查询，你可以针对不同的媒体类型定义不同的样式。</p>
<h3 id="1rem、1em、1vh、1px各自代表的含义？"><a href="#1rem、1em、1vh、1px各自代表的含义？" class="headerlink" title="1rem、1em、1vh、1px各自代表的含义？"></a>1rem、1em、1vh、1px各自代表的含义？</h3><blockquote><p>rem<br>rem是全部的长度都相对于根元素元素。通常做法是给html元素设置一个字体大小，然后其他元素的长度单位就为rem。<br>em<br>子元素字体大小的em是相对于父元素字体大小<br>元素的width&#x2F;height&#x2F;padding&#x2F;margin用em的话是相对于该元素的font-size<br>vw&#x2F;vh<br>全称是 Viewport Width 和 Viewport Height，视窗的宽度和高度，相当于 屏幕宽度和高度的 1%，不过，处理宽度的时候%单位更合适，处理高度的 话 vh 单位更好。<br>px<br>px像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的。<br>一般电脑的分辨率有{1920 x 1024}等不同的分辨率<br>1920 x 1024 前者是屏幕宽度总共有1920个像素,后者则是高度为1024个像素</p>
</blockquote>
<h3 id="画一个三角形？"><a href="#画一个三角形？" class="headerlink" title="画一个三角形？"></a>画一个三角形？</h3><p>这属于简单的css考查，平时在用组件库的同时，也别忘了原生的css</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.a &#123;</span><br><span class="line">    width: 0;</span><br><span class="line">    height: 0;</span><br><span class="line">    border-width: 100px;</span><br><span class="line">    border-style: solid;</span><br><span class="line">    border-color: transparent <span class="comment">#0099CC transparent transparent;</span></span><br><span class="line">    transform: rotate(90deg); /*顺时针旋转90°*/</span><br><span class="line">&#125;</span><br><span class="line">&lt;div class=<span class="string">&quot;a&quot;</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h2 id="HTML-x2F-CSS-混合篇"><a href="#HTML-x2F-CSS-混合篇" class="headerlink" title="HTML &#x2F; CSS 混合篇"></a>HTML &#x2F; CSS 混合篇</h2><h3 id="HTML5、CSS3-里面都新增了那些新特性？"><a href="#HTML5、CSS3-里面都新增了那些新特性？" class="headerlink" title="HTML5、CSS3 里面都新增了那些新特性？"></a>HTML5、CSS3 里面都新增了那些新特性？</h3><h3 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h3><p>新的语义标签<br>article 独立的内容。<br>aside 侧边栏。<br>header 头部。<br>nav 导航。<br>section 文档中的节。<br>footer 页脚。<br>画布(Canvas) API<br>地理(Geolocation) API<br>本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；<br>sessionStorage 的数据在浏览器关闭后自动删除<br>新的技术webworker, websocket, Geolocation<br>拖拽释放(Drag and drop) API<br>音频、视频API(audio,video)<br>表单控件，calendar、date、time、email、url、searc</p>
<h3 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h3><p>2d，3d变换<br>Transition, animation<br>媒体查询<br>新的单位（rem, vw，vh 等）<br>圆角（border-radius），阴影（box-shadow），对文字加特效（text-shadow），线性渐变（gradient），旋转（transform）transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);&#x2F;&#x2F;旋转,缩放,定位,倾斜<br>rgba</p>
<h3 id="BFC-是什么？"><a href="#BFC-是什么？" class="headerlink" title="BFC 是什么？"></a>BFC 是什么？</h3><p>BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于普通流，即：元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。<br>可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。<br>只要元素满足下面任一条件即可触发 BFC 特性</p>
<p>body 根元素<br>浮动元素：float 除 none 以外的值<br>绝对定位元素：position (absolute、fixed)<br>display 为 inline-block、table-cells、flex<br>overflow 除了 visible 以外的值 (hidden、auto、scroll)</p>
<h3 id="常见兼容性问题？"><a href="#常见兼容性问题？" class="headerlink" title="常见兼容性问题？"></a>常见兼容性问题？</h3><p>浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。<br>Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,<br>可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决.</p>
<h2 id="JS-篇"><a href="#JS-篇" class="headerlink" title="JS 篇"></a>JS 篇</h2><h3 id="JS-数据类型"><a href="#JS-数据类型" class="headerlink" title="JS 数据类型 ?"></a>JS 数据类型 ?</h3><p>数据类型主要包括两部分：</p>
<p>基本数据类型： Undefined、Null、Boolean、Number 和 String<br>引用数据类型： Object (包括 Object 、Array 、Function)<br>ECMAScript 2015 新增:Symbol(创建后独一无二且不可变的数据类型 )</p>
<h3 id="判断一个值是什么类型有哪些方法？"><a href="#判断一个值是什么类型有哪些方法？" class="headerlink" title="判断一个值是什么类型有哪些方法？"></a>判断一个值是什么类型有哪些方法？</h3><p>typeof 运算符<br>instanceof 运算符<br>Object.prototype.toString 方法</p>
<h3 id="null-和-undefined-的区别？"><a href="#null-和-undefined-的区别？" class="headerlink" title="null 和 undefined 的区别？"></a>null 和 undefined 的区别？</h3><p>null 表示一个对象被定义了，值为“空值”；<br>undefined 表示不存在这个值。<br>（1）变量被声明了，但没有赋值时，就等于undefined。 （2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。 （3）对象没有赋值的属性，该属性的值为undefined。 （4）函数没有返回值时，默认返回undefined。</p>
<h3 id="怎么判断一个变量arr的话是否为数组（此题用-typeof-不行）？"><a href="#怎么判断一个变量arr的话是否为数组（此题用-typeof-不行）？" class="headerlink" title="怎么判断一个变量arr的话是否为数组（此题用 typeof 不行）？"></a>怎么判断一个变量arr的话是否为数组（此题用 typeof 不行）？</h3><p>arr instanceof Array<br>arr.constructor &#x3D;&#x3D; Array<br>Object.protype.toString.call(arr) &#x3D;&#x3D; ‘[Object Array]’</p>
<h3 id="“-x3D-x3D-x3D-”、“-x3D-x3D-”的区别？"><a href="#“-x3D-x3D-x3D-”、“-x3D-x3D-”的区别？" class="headerlink" title="“ &#x3D;&#x3D;&#x3D;”、“ &#x3D;&#x3D;”的区别？"></a>“ &#x3D;&#x3D;&#x3D;”、“ &#x3D;&#x3D;”的区别？</h3><p>&#x3D;&#x3D;，当且仅当两个运算数相等时，它返回 true，即不检查数据类型<br>&#x3D;&#x3D;&#x3D;，只有在无需类型转换运算数就相等的情况下，才返回 true，需要检查数据类型</p>
<h3 id="“eval是做什么的？"><a href="#“eval是做什么的？" class="headerlink" title="“eval是做什么的？"></a>“eval是做什么的？</h3><p>它的功能是把对应的字符串解析成 JS 代码并运行；<br>应该避免使用 eval，不安全，非常耗性能（2次，一次解析成 js 语句，一次执行）。</p>
<h3 id="箭头函数有哪些特点？"><a href="#箭头函数有哪些特点？" class="headerlink" title="箭头函数有哪些特点？"></a>箭头函数有哪些特点？</h3><p>不需要function关键字来创建函数<br>省略return关键字<br>改变this指向</p>
<h3 id="var、let、const-区别？"><a href="#var、let、const-区别？" class="headerlink" title="var、let、const 区别？"></a>var、let、const 区别？</h3><p>var 存在变量提升。<br>let 只能在块级作用域内访问。<br>const 用来定义常量，必须初始化，不能修改（对象特殊）</p>
<h3 id="new操作符具体干了什么呢？"><a href="#new操作符具体干了什么呢？" class="headerlink" title="new操作符具体干了什么呢？"></a>new操作符具体干了什么呢？</h3><p>1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。<br>2、属性和方法被加入到 this 引用的对象中。<br>3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。</p>
<h3 id="JSON-的了解？"><a href="#JSON-的了解？" class="headerlink" title="JSON 的了解？"></a>JSON 的了解？</h3><p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。<br>它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小<br>{‘age’:‘12’, ‘name’:‘back’}</p>
<h3 id="documen-write-和-innerHTML-的区别？"><a href="#documen-write-和-innerHTML-的区别？" class="headerlink" title="documen.write 和 innerHTML 的区别？"></a>documen.write 和 innerHTML 的区别？</h3><p>document.write 只能重绘整个页面<br>innerHTML 可以重绘页面的一部分</p>
<h3 id="ajax过程？"><a href="#ajax过程？" class="headerlink" title="ajax过程？"></a>ajax过程？</h3><p>(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象.<br>(2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.<br>(3)设置响应HTTP请求状态变化的函数.<br>(4)发送HTTP请求.<br>(5)获取异步调用返回的数据.<br>(6)使用JavaScript和DOM实现局部刷新.</p>
<h3 id="请解释一下-JavaScript-的同源策略？"><a href="#请解释一下-JavaScript-的同源策略？" class="headerlink" title="请解释一下 JavaScript 的同源策略？"></a>请解释一下 JavaScript 的同源策略？</h3><p>概念:同源策略是客户端脚本（尤其是Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。<br>这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。<br>指一段脚本只能读取来自同一来源的窗口和文档的属性。</p>
<h3 id="介绍一下闭包和闭包常用场景？"><a href="#介绍一下闭包和闭包常用场景？" class="headerlink" title="介绍一下闭包和闭包常用场景？"></a>介绍一下闭包和闭包常用场景？</h3><p>闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包常见方式，就是在一个函数的内部创建另一个函数<br>使用闭包主要为了设计私有的方法和变量，闭包的优点是可以避免变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念。<br>闭包有三个特性：<br>函数嵌套函数<br>函数内部可以引用外部的参数和变量<br>参数和变量不会被垃圾回收机制回收<br>应用场景，设置私有变量的方法<br>不适用场景：返回闭包的函数是个非常大的函数<br>闭包的缺点就是常驻内存，会增大内存使用量，使用不当会造成内存泄漏</p>
<h3 id="javascript的内存-垃圾-回收机制？"><a href="#javascript的内存-垃圾-回收机制？" class="headerlink" title="javascript的内存(垃圾)回收机制？"></a>javascript的内存(垃圾)回收机制？</h3><p>垃圾回收器会每隔一段时间找出那些不再使用的内存，然后为其释放内存<br>一般使用标记清除方法(mark and sweep), 当变量进入环境标记为进入环境，离开环境标记为离开环境<br>垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了<br>还有引用计数方法(reference counting), 在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间。<br>在IE中虽然JavaScript对象通过标记清除的方式进行垃圾回收，但BOM与DOM对象却是通过引用计数回收垃圾的， 也就是说只要涉及BOM及DOM就会出现循环引用问题。</p>
<h3 id="JavaScript原型，原型链-有什么特点？"><a href="#JavaScript原型，原型链-有什么特点？" class="headerlink" title="JavaScript原型，原型链 ? 有什么特点？"></a>JavaScript原型，原型链 ? 有什么特点？</h3><p>任何对象都有 proto 隐式原型, 等于 构造函数 的 prototype</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;&#125;</span><br><span class="line">obj.__proto__ === Object.prototype // <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>任何函数都有 prototype 显示原型 等于 原型对象(就是一个普通对象包含公共属性)<br>*(通过Function.prototype.bind方法构造出来的函数是个例外，它没有prototype属性)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Person</span></span> () &#123;&#125;</span><br><span class="line">Person.prototype = 原型对象</span><br><span class="line">Person.prototype.constructor === Person // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">const person1 = new Person</span><br><span class="line">person1.__proto__ === Person.prototype // <span class="literal">true</span></span><br><span class="line">person1.constructor == Person // <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>对象还具有 constructor 属性，指向构造函数（Person.prototype.constructor &#x3D;&#x3D; Person）<br>原型链是依赖于__proto__, 查找一个属性会沿着 proto 原型链向上查找，直到找到为止。<br>特殊<br>&#x2F;&#x2F; 原型链最终点是 null </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.__proto__ === null // <span class="literal">true</span></span><br><span class="line">obj.__proto__.__proto__ === null // <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，<br>如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，<br>于是就这样一直找下去，也就是我们平时所说的原型链的概念。<br>关系：instance.constructor.prototype &#x3D; instance.proto<br>特点：<br>JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。</p>
<h3 id="用js递归的方式写1到100求和？"><a href="#用js递归的方式写1到100求和？" class="headerlink" title="用js递归的方式写1到100求和？"></a>用js递归的方式写1到100求和？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> add(num1, num2) &#123;</span><br><span class="line">	const num = num1 + num2;</span><br><span class="line">    <span class="keyword">if</span>(num2 === 100) &#123;</span><br><span class="line">        <span class="built_in">return</span> num;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    <span class="built_in">return</span> add(num, num2 + 1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var <span class="built_in">sum</span> = add(1, 2);              </span><br></pre></td></tr></table></figure>
<h3 id="事件队列（宏任务微任务）"><a href="#事件队列（宏任务微任务）" class="headerlink" title="事件队列（宏任务微任务）"></a>事件队列（宏任务微任务）</h3><p>可以分为微任务（micro task）队列和宏任务（macro task）队列。</p>
<p>微任务一般比宏任务先执行，并且微任务队列只有一个，宏任务队列可能有多个。另外我们常见的点击和键盘等事件也属于宏任务。</p>
<p>下面我们看一下常见宏任务和常见微任务。</p>
<p>常见宏任务：</p>
<p>setTimeout()<br>setInterval()<br>setImmediate()<br>常见微任务：</p>
<p>promise.then()、promise.catch()<br>new MutaionObserver()<br>process.nextTick()<br>微任务和宏任务的本质区别。</p>
<p>宏任务特征：有明确的异步任务需要执行和回调；需要其他异步线程支持。<br>微任务特征：没有明确的异步任务需要执行，只有回调；不需要其他异步线程支持。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125;, 0);</span><br><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">async1</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    const data = await async2();</span><br><span class="line">    console.log(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    <span class="built_in">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">async2</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> new Promise((resolve) =&gt; &#123;</span><br><span class="line">        console.log(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        resolve(<span class="string">&quot;async2的结果&quot;</span>);</span><br><span class="line">    &#125;).<span class="keyword">then</span>((data) =&gt; &#123;</span><br><span class="line">        console.log(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        <span class="built_in">return</span> data;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">async1().<span class="keyword">then</span>((data) =&gt; &#123;</span><br><span class="line">    console.log(<span class="string">&quot;6&quot;</span>);</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;);</span><br><span class="line">new Promise(<span class="keyword">function</span> (resolve) &#123;</span><br><span class="line">    console.log(<span class="string">&quot;7&quot;</span>);</span><br><span class="line">  resolve()</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(<span class="string">&quot;8&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 2 4 7 5 8 3 6 async2的结果 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="async-x2F-await"><a href="#async-x2F-await" class="headerlink" title="async&#x2F;await"></a>async&#x2F;await</h3><p>async 是一个通过异步执行并隐式返回 Promise 作为结果的函数。是Generator函数的语法糖，并对Generator函数进行了改进。<br>改进：</p>
<p>内置执行器，无需手动执行 next() 方法。<br>更好的语义<br>更广的适用性：co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。<br>返回值是 Promise，比 Generator 函数返回的 Iterator 对象方便，可以直接使用 then() 方法进行调用。<br>async 隐式返回 Promise 作为结果的函数，那么可以简单理解为，await后面的函数执行完毕时，await会产生一个微任务(Promise.then是微任务)。</p>
<h3 id="JavaScript-是单线程的，浏览器是多进程的"><a href="#JavaScript-是单线程的，浏览器是多进程的" class="headerlink" title="JavaScript 是单线程的，浏览器是多进程的"></a>JavaScript 是单线程的，浏览器是多进程的</h3><p>每打开一个新网页就会创建一个渲染进程<br>渲染进程是多线程的<br>负责页面渲染的 GUI 渲染线程<br>负责JavaScript的执行的 JavaScript 引擎线程，<br>负责浏览器事件循环的事件触发线程，注意这不归 JavaScript 引擎线程管<br>负责定时器的定时触发器线程，setTimeout 中低于 4ms 的时间间隔算为4ms<br>负责XMLHttpRequest的异步 http 请求线程<br>GUI 渲染线程与 JavaScript 引擎线程是互斥的<br>单线程JavaScript是因为避免 DOM 渲染的冲突，web worker 支持多线程，但是 web worker 不能访问 window 对象，document 对象等。</p>
<h2 id="Vue-篇"><a href="#Vue-篇" class="headerlink" title="Vue 篇"></a>Vue 篇</h2><h3 id="谈谈你对MVVM开发模式的理解？"><a href="#谈谈你对MVVM开发模式的理解？" class="headerlink" title="谈谈你对MVVM开发模式的理解？"></a>谈谈你对MVVM开发模式的理解？</h3><p>MVVM分为Model、View、ViewModel三者。<br>Model 代表数据模型，数据和业务逻辑都在Model层中定义；<br>View 代表UI视图，负责数据的展示；<br>ViewModel 负责监听 Model 中数据的改变并且控制视图的更新，处理用户交互操作；<br>Model 和 View 并无直接关联，而是通过 ViewModel 来进行联系的，Model 和 ViewModel 之间有着双向数据绑定的联系。因此当 Model 中的数据改变时会触发 View 层的刷新，View 中由于用户交互操作而改变的数据也会在 Model 中同步。<br>这种模式实现了 Model 和 View 的数据自动同步，因此开发者只需要专注对数据的维护操作即可，而不需要自己操作 dom。</p>
<h3 id="v-if-和-v-show-有什么区别？"><a href="#v-if-和-v-show-有什么区别？" class="headerlink" title="v-if 和 v-show 有什么区别？"></a>v-if 和 v-show 有什么区别？</h3><p>v-if 是真正的条件渲染，会控制这个 DOM 节点的存在与否。因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。<br>v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 “display” 属性进行切换。<br>当我们需要经常切换某个元素的显示&#x2F;隐藏时，使用v-show会更加节省性能上的开销；当只需要一次显示或隐藏时，使用v-if更加合理。</p>
<h3 id="你使用过-Vuex-吗？"><a href="#你使用过-Vuex-吗？" class="headerlink" title="你使用过 Vuex 吗？"></a>你使用过 Vuex 吗？</h3><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。</p>
<p>（1）Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。<br>（2）改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。<br>主要包括以下几个模块：</p>
<p>State &#x3D;&gt; 基本数据，定义了应用状态的数据结构，可以在这里设置默认的初始状态。<br>Getter &#x3D;&gt; 从基本数据派生的数据，允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。<br>Mutation &#x3D;&gt; 是唯一更改 store 中状态的方法，且必须是同步函数。<br>Action &#x3D;&gt; 像一个装饰器，包裹mutations，使之可以异步。用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。<br>Module &#x3D;&gt; 模块化Vuex，允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。</p>
<h3 id="说说你对-SPA-单页面的理解，它的优缺点分别是什么？"><a href="#说说你对-SPA-单页面的理解，它的优缺点分别是什么？" class="headerlink" title="说说你对 SPA 单页面的理解，它的优缺点分别是什么？"></a>说说你对 SPA 单页面的理解，它的优缺点分别是什么？</h3><p>SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页&gt; 面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 &gt; HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。</p>
<p>优点：<br>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；<br>基于上面一点，SPA 相对对服务器压力小；<br>前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；<br>缺点：<br>初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一&gt; 加载，部分页面按需加载；<br>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所&gt; 有的页面切换需要自己建立堆栈管理；<br>SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。</p>
<h3 id="Class-与-Style-如何动态绑定？"><a href="#Class-与-Style-如何动态绑定？" class="headerlink" title="Class 与 Style 如何动态绑定？"></a>Class 与 Style 如何动态绑定？</h3><p>Class 可以通过对象语法和数组语法进行动态绑定：</p>
<p>对象语法：</p>
<div v-bind:class="{ active: isActive, 'text-danger': hasError }"></div>
data: {
    isActive: true,
      hasError: false
}

<p>数组语法：</p>
<div v-bind:class="[isActive ? activeClass : '', errorClass]"></div>
data: {
  activeClass: 'active',
  errorClass: 'text-danger'
}

<p>Style 也可以通过对象语法和数组语法进行动态绑定：</p>
<p>对象语法：</p>
<div v-bind:style="{ color: activeColor, fontSize: fontSize + 'px' }"></div>
data: {
  activeColor: 'red',
  fontSize: 30
}

<p>数组语法：</p>
<div v-bind:style="[styleColor, styleSize]"></div>
data: {
  styleColor: {
     color: 'red'
   },
  styleSize:{
     fontSize:'23px'
  }
}

<h3 id="怎样理解-Vue-的单向数据流？"><a href="#怎样理解-Vue-的单向数据流？" class="headerlink" title="怎样理解 Vue 的单向数据流？"></a>怎样理解 Vue 的单向数据流？</h3><p>所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。<br>这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。<br>额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。<br>这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。<br>子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。</p>
<h3 id="computed-和-watch-的区别和运用的场景？"><a href="#computed-和-watch-的区别和运用的场景？" class="headerlink" title="computed 和 watch 的区别和运用的场景？"></a>computed 和 watch 的区别和运用的场景？</h3><p>computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；<br>watch： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；<br>运用场景：<br>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；<br>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p>
<h3 id="直接给一个数组项赋值，Vue-能检测到变化吗？"><a href="#直接给一个数组项赋值，Vue-能检测到变化吗？" class="headerlink" title="直接给一个数组项赋值，Vue 能检测到变化吗？"></a>直接给一个数组项赋值，Vue 能检测到变化吗？</h3><p>由于 JavaScript 的限制，Vue 不能检测到以下数组的变动：</p>
<p>当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] &#x3D; newValue<br>当你修改数组的长度时，例如：vm.items.length &#x3D; newLength<br>为了解决第一个问题，Vue 提供了以下操作方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Vue.<span class="built_in">set</span></span><br><span class="line">Vue.<span class="built_in">set</span>(vm.items, indexOfItem, newValue)</span><br><span class="line">// vm.<span class="variable">$set</span>，Vue.<span class="built_in">set</span>的一个别名</span><br><span class="line">vm.<span class="variable">$set</span>(vm.items, indexOfItem, newValue)</span><br><span class="line">// Array.prototype.splice</span><br><span class="line">vm.items.splice(indexOfItem, 1, newValue)</span><br></pre></td></tr></table></figure>
<p>为了解决第二个问题，Vue 提供了以下操作方法：<br>&#x2F;&#x2F; Array.prototype.splice<br>vm.items.splice(newLength)</p>
<h3 id="谈谈你对-Vue-生命周期的理解？"><a href="#谈谈你对-Vue-生命周期的理解？" class="headerlink" title="谈谈你对 Vue 生命周期的理解？"></a>谈谈你对 Vue 生命周期的理解？</h3><p>生命周期是什么？<br>Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载 Dom -&gt; 渲染、更新 -&gt; 渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。</p>
<p>各个生命周期的作用</p>
<blockquote><p>生命周期	描述<br>beforeCreate	组件实例被创建之初，组件的属性生效之前<br>created	组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用<br>beforeMount	在挂载开始之前被调用：相关的 render 函数首次被调用<br>mounted	el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子<br>beforeUpdate	组件数据更新之前调用，发生在虚拟 DOM 打补丁之前<br>updated	组件数据更新之后<br>activited	keep-alive 专属，组件被激活时调用<br>deadctivated	keep-alive 专属，组件被销毁时调用<br>beforeDestory	组件销毁前调用<br>destoryed	组件销毁后调用</p>
</blockquote>

<h3 id="Vue-的父组件和子组件生命周期钩子函数执行顺序？"><a href="#Vue-的父组件和子组件生命周期钩子函数执行顺序？" class="headerlink" title="Vue 的父组件和子组件生命周期钩子函数执行顺序？"></a>Vue 的父组件和子组件生命周期钩子函数执行顺序？</h3><p>Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分：</p>
<p>加载渲染过程 :<br>父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted<br>子组件更新过程 :<br>父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated<br>父组件更新过程 :<br>父 beforeUpdate -&gt; 父 updated<br>销毁过程 :<br>父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</p>
<h3 id="父组件可以监听到子组件的生命周期吗？"><a href="#父组件可以监听到子组件的生命周期吗？" class="headerlink" title="父组件可以监听到子组件的生命周期吗？"></a>父组件可以监听到子组件的生命周期吗？</h3><p>比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理，可以通过以下写法实现：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Parent.vue</span><br><span class="line">&lt;Child @mounted=<span class="string">&quot;doSomething&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">// Child.vue</span><br><span class="line"><span class="function"><span class="title">mounted</span></span>() &#123;</span><br><span class="line">  this.<span class="variable">$emit</span>(<span class="string">&quot;mounted&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上需要手动通过 $emit 触发父组件的事件，更简单的方式可以在父组件引用子组件时通过 @hook 来监听即可，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//  Parent.vue</span><br><span class="line">&lt;Child @hook:mounted=<span class="string">&quot;doSomething&quot;</span> &gt;&lt;/Child&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">doSomething</span></span>() &#123;</span><br><span class="line">   console.log(<span class="string">&#x27;父组件监听到 mounted 钩子函数 ...&#x27;</span>);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">//  Child.vue</span><br><span class="line"><span class="function"><span class="title">mounted</span></span>()&#123;</span><br><span class="line">   console.log(<span class="string">&#x27;子组件触发 mounted 钩子函数 ...&#x27;</span>);</span><br><span class="line">&#125;,    </span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F; 以上输出顺序为：<br>&#x2F;&#x2F; 子组件触发 mounted 钩子函数 …<br>&#x2F;&#x2F; 父组件监听到 mounted 钩子函数 …<br>1<br>当然 @hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听。</p>
<h3 id="谈谈你对-keep-alive-的了解？"><a href="#谈谈你对-keep-alive-的了解？" class="headerlink" title="谈谈你对 keep-alive 的了解？"></a>谈谈你对 keep-alive 的了解？</h3><p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性：</p>
<p>一般结合路由和动态组件一起使用，用于缓存组件；<br>提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；<br>对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。</p>
<h3 id="组件中-data-为什么是一个函数？"><a href="#组件中-data-为什么是一个函数？" class="headerlink" title="组件中 data 为什么是一个函数？"></a>组件中 data 为什么是一个函数？</h3><p>为什么组件中的 data 必须是一个函数，然后 return 一个对象，而 new Vue 实例里，data 可以直接是一个对象？<br>因为组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响，<br>如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响；而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。</p>
<h3 id="v-model-的原理？"><a href="#v-model-的原理？" class="headerlink" title="v-model 的原理？"></a>v-model 的原理？</h3><p>我们在 vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，我们知道 v-model 本质上不过是语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：</p>
<p>text 和 textarea 元素使用 value 属性和 input 事件；<br>checkbox 和 radio 使用 checked 属性和 change 事件；<br>select 字段将 value 作为 prop 并将 change 作为事件。<br>以 input 表单元素为例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=<span class="string">&#x27;something&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>
<p>相当于</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-bind:value=<span class="string">&quot;something&quot;</span> v-on:input=<span class="string">&quot;something = <span class="variable">$event</span>.target.value&quot;</span>&gt;</span><br></pre></td></tr></table></figure>
<p>如果在自定义组件中，v-model 默认会利用名为 value 的 prop 和名为 input 的事件，如下所示：</p>
<p>父组件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ModelChild v-model=<span class="string">&quot;message&quot;</span>&gt;&lt;/ModelChild&gt;</span><br></pre></td></tr></table></figure>
<p>子组件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&#123;&#123;value&#125;&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">props:&#123;</span><br><span class="line">    value: String</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  <span class="function"><span class="title">test1</span></span>()&#123;</span><br><span class="line">     this.<span class="variable">$emit</span>(<span class="string">&#x27;input&#x27;</span>, <span class="string">&#x27;小红&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h3 id="Vue-组件间通信有哪几种方式？"><a href="#Vue-组件间通信有哪几种方式？" class="headerlink" title="Vue 组件间通信有哪几种方式？"></a>Vue 组件间通信有哪几种方式？</h3><p>Vue 组件间通信是面试常考的知识点之一，这题有点类似于开放题，你回答出越多方法当然越加分，表明你对 Vue 掌握的越熟练。</p>
<p>Vue 组件间通信只要指以下 3 类通信：父子组件通信、隔代组件通信、兄弟组件通信，下面我们分别介绍每种通信方式且会说明此种方法可适用于哪类组件间通信。<blockquote><p>（1）props &#x2F; $emit 适用 父子组件通信</p>
<p>这种方法是 Vue 组件的基础，相信大部分同学耳闻能详，所以此处就不举例展开介绍。<br>（2）ref 与 $parent &#x2F; $children适用 父子组件通信</p>
<p>ref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例<br>$parent &#x2F; $children：访问父 &#x2F; 子实例<br>（3）EventBus （$emit &#x2F; $on）适用于 父子、隔代、兄弟组件通信</p>
<p>这种方法通过一个空的 Vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件。<br>（4）$attrs&#x2F;$listeners适用于 隔代组件通信</p>
<p>$attrs：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过 v-bind&#x3D;”$attrs” 传入内部组件。通常配合 inheritAttrs 选项一起使用。<br>$listeners：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on&#x3D;”$listeners” 传入内部组件<br>（5）provide &#x2F; inject适用于 隔代组件通信</p>
<p>祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。provide &#x2F; inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。<br>（6）Vuex适用于 父子、隔代、兄弟组件通信</p>
<p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。<br>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。<br>改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。</p>
</blockquote></p>
<h3 id="使用过-Vue-SSR-吗？说说-SSR？"><a href="#使用过-Vue-SSR-吗？说说-SSR？" class="headerlink" title="使用过 Vue SSR 吗？说说 SSR？"></a>使用过 Vue SSR 吗？说说 SSR？</h3><p>Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记”激活”为客户端上完全可交互的应用程序。<br>即：SSR大致的意思就是vue在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的html 片段直接返回给客户端这个过程就叫做服务端渲染。<br>服务端渲染 SSR 的优缺点如下：</p>
<p>（1）服务端渲染的优点：<br>更好的 SEO：因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；<br>更快的内容到达时间（首屏加载更快）：SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间；<br>（2) 服务端渲染的缺点：<br>更多的开发条件限制：例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；<br>更多的服务器负载：在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic ) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。</p>
<h3 id="vue-router-路由模式有几种？"><a href="#vue-router-路由模式有几种？" class="headerlink" title="vue-router 路由模式有几种？"></a>vue-router 路由模式有几种？</h3><p>vue-router 有 3 种路由模式：hash、history、abstract，对应的源码如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">switch (mode) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;history&#x27;</span>:</span><br><span class="line">    this.history = new HTML5History(this, options.base)</span><br><span class="line">    <span class="built_in">break</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;hash&#x27;</span>:</span><br><span class="line">    this.history = new HashHistory(this, options.base, this.fallback)</span><br><span class="line">    <span class="built_in">break</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;abstract&#x27;</span>:</span><br><span class="line">    this.history = new AbstractHistory(this, options.base)</span><br><span class="line">    <span class="built_in">break</span></span><br><span class="line">  default:</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      assert(<span class="literal">false</span>, `invalid mode: <span class="variable">$&#123;mode&#125;</span>`)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，3 种路由模式的说明如下：</p>
<p>hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器；<br>history : 依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式；<br>abstract : 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.</p>
<h3 id="能说下-vue-router-中常用的-hash-和-history-路由模式实现原理吗？"><a href="#能说下-vue-router-中常用的-hash-和-history-路由模式实现原理吗？" class="headerlink" title="能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？"></a>能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？</h3><p>（1）hash 模式的实现原理<br>早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 ‘#search’：<br><a target="_blank" rel="noopener" href="https://www.word.com/#search">https://www.word.com#search</a><br>hash 路由模式的实现主要是基于下面几个特性：</p>
<p>URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送；<br>hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换；<br>可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用 JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值；<br>我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。<br>（2）history 模式的实现原理<br>HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。<br>唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示：<br>window.history.pushState(null, null, path);<br>window.history.replaceState(null, null, path);<br>history 路由模式的实现主要基于存在下面几个特性：</p>
<p>pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ；<br>我们可以使用 popstate 事件来监听 url 的变化，从而对页面进行跳转（渲染）；<br>history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。</p>
<h3 id="Vue-框架怎么实现对象和数组的监听？"><a href="#Vue-框架怎么实现对象和数组的监听？" class="headerlink" title="Vue 框架怎么实现对象和数组的监听？"></a>Vue 框架怎么实现对象和数组的监听？</h3><p>Vue 数据双向绑定主要是指：数据变化更新视图，视图变化更新数据。<br>即：</p>
<p>输入框内容变化时，Data 中的数据同步变化。即 View &#x3D;&gt; Data 的变化。<br>Data 中的数据变化时，文本节点的内容同步变化。即 Data &#x3D;&gt; View 的变化。<br>其中，View 变化更新 Data ，可以通过事件监听的方式来实现，所以 Vue 的数据双向绑定的工作主要是如何根据 Data 变化更新 View。<br>Vue 主要通过以下 4 个步骤来实现数据双向绑定的：</p>
<p>实现一个监听器 Observer：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。<br>实现一个解析器 Compile：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。<br>实现一个订阅者 Watcher：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。<br>实现一个订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。</p>
<h3 id="Vue-是如何实现数据双向绑定的？"><a href="#Vue-是如何实现数据双向绑定的？" class="headerlink" title="Vue 是如何实现数据双向绑定的？"></a>Vue 是如何实现数据双向绑定的？</h3><p>如果被问到 Vue 怎么实现数据双向绑定，大家肯定都会回答 通过 Object.defineProperty() 对数据进行劫持，但是 Object.defineProperty() 只能对属性进行数据劫持，不能对整个对象进行劫持。<br>同理无法对数组进行劫持，但是我们在使用 Vue 框架中都知道，Vue 能检测到对象和数组（部分方法的操作）的变化，那它是怎么实现的呢？我们查看相关代码如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Observe a list of Array items.</span><br><span class="line"> */</span><br><span class="line">observeArray (items: Array&lt;any&gt;) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">let</span> i = 0, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">    observe(items[i])  // observe 功能为监测数据的变化</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 对属性进行递归遍历</span><br><span class="line"> */</span><br><span class="line"><span class="built_in">let</span> childOb = !shallow &amp;&amp; observe(val) // observe 功能为监测数据的变化</span><br></pre></td></tr></table></figure>
<p>通过以上 Vue 源码部分查看，我们就能知道 Vue 框架是通过遍历数组 和递归遍历对象，从而达到利用 Object.defineProperty() 也能对对象和数组（部分方法的操作）进行监听。</p>
<h3 id="Vue-怎么用-vm-set-解决对象新增属性不能响应的问题-？"><a href="#Vue-怎么用-vm-set-解决对象新增属性不能响应的问题-？" class="headerlink" title="Vue 怎么用 vm.$set() 解决对象新增属性不能响应的问题 ？"></a>Vue 怎么用 vm.$set() 解决对象新增属性不能响应的问题 ？</h3><p>受现代 JavaScript 的限制 ，Vue 无法检测到对象属性的添加或删除。<br>由于 Vue 会在初始化实例时对属性执行 getter&#x2F;setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。<br>但是 Vue 提供了 Vue.set (object, propertyName, value) &#x2F; vm.$set (object, propertyName, value)来实现为对象添加响应式属性，那框架本身是如何实现的呢？</p>
<p>我们查看对应的 Vue 源码：vue&#x2F;src&#x2F;core&#x2F;instance&#x2F;index.js</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> <span class="built_in">set</span> (target: Array&lt;any&gt; | Object, key: any, val: any): any &#123;</span><br><span class="line">  // target 为数组</span><br><span class="line">  <span class="keyword">if</span> (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;</span><br><span class="line">    // 修改数组的长度, 避免索引&gt;数组长度导致splcie()执行有误</span><br><span class="line">    target.length = Math.max(target.length, key)</span><br><span class="line">    // 利用数组的splice变异方法触发响应式</span><br><span class="line">    target.splice(key, 1, val)</span><br><span class="line">    <span class="built_in">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  // key 已经存在，直接修改属性值</span><br><span class="line">  <span class="keyword">if</span> (key <span class="keyword">in</span> target &amp;&amp; !(key <span class="keyword">in</span> Object.prototype)) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    <span class="built_in">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  const ob = (target: any).__ob__</span><br><span class="line">  // target 本身就不是响应式数据, 直接赋值</span><br><span class="line">  <span class="keyword">if</span> (!ob) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    <span class="built_in">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  // 对属性进行响应式处理</span><br><span class="line">  defineReactive(ob.value, key, val)</span><br><span class="line">  ob.dep.notify()</span><br><span class="line">  <span class="built_in">return</span> val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们阅读以上源码可知，vm.$set 的实现原理是：</p>
<p>如果目标是数组，直接使用数组的 splice 方法触发相应式；<br>如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 defineReactive 方法进行响应式处理（ defineReactive 方法就是 Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法）</p>
<h3 id="虚拟-DOM-的优缺点？"><a href="#虚拟-DOM-的优缺点？" class="headerlink" title="虚拟 DOM 的优缺点？"></a>虚拟 DOM 的优缺点？</h3><p>优点：</p>
<p>保证性能下限： 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；<br>无需手动操作 DOM： 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；<br>跨平台： 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。<br>缺点:</p>
<p>无法进行极致优化： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。</p>
<h3 id="虚拟-DOM-实现原理？"><a href="#虚拟-DOM-实现原理？" class="headerlink" title="虚拟 DOM 实现原理？"></a>虚拟 DOM 实现原理？</h3><p>虚拟 DOM 的实现原理主要包括以下 3 部分：</p>
<p>用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；<br>diff 算法 — 比较两棵虚拟 DOM 树的差异；<br>pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。</p>
<h3 id="Vue-中的-key-有什么作用？"><a href="#Vue-中的-key-有什么作用？" class="headerlink" title="Vue 中的 key 有什么作用？"></a>Vue 中的 key 有什么作用？</h3><p>key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速。<br>Vue 的 diff 过程可以概括为：oldCh 和 newCh 各有两个头尾的变量 oldStartIndex、oldEndIndex 和 newStartIndex、newEndIndex，它们会新节点和旧节点会进行两两对比，即一共有4种比较方式：newStartIndex 和oldStartIndex 、newEndIndex 和 oldEndIndex 、newStartIndex 和 oldEndIndex 、newEndIndex 和 oldStartIndex，如果以上 4 种比较都没匹配，如果设置了key，就会用 key 再进行比较，在比较的过程中，遍历会往中间靠，一旦 StartIdx &gt; EndIdx 表明 oldCh 和 newCh 至少有一个已经遍历完了，就会结束比较。<br>所以 Vue 中 key 的作用是：key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速!</p>
<p>更准确：因为带 key 就不是就地复用了，在 sameNode 函数 a.key &#x3D;&#x3D;&#x3D; b.key 对比中可以避免就地复用的情况。所以会更加准确。<br>更快速：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快，源码如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> createKeyToOldIdx (children, beginIdx, endIdx) &#123;</span><br><span class="line">  <span class="built_in">let</span> i, key</span><br><span class="line">  const map = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (i = beginIdx; i &lt;= endIdx; ++i) &#123;</span><br><span class="line">    key = children[i].key</span><br><span class="line">    <span class="keyword">if</span> (isDef(key)) map[key] = i</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> map</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="你有对-Vue-项目进行哪些优化？"><a href="#你有对-Vue-项目进行哪些优化？" class="headerlink" title="你有对 Vue 项目进行哪些优化？"></a>你有对 Vue 项目进行哪些优化？</h3><p>（1）代码层面的优化</p>
<p>v-if 和 v-show 区分使用场景<br>computed 和 watch 区分使用场景<br>v-for 遍历必须为 item 添加 key，且避免同时使用 v-if<br>长列表性能优化<br>事件的销毁<br>图片资源懒加载<br>路由懒加载<br>第三方插件的按需引入<br>优化无限列表性能<br>服务端渲染 SSR or 预渲染<br>（2）Webpack 层面的优化</p>
<p>Webpack 对图片进行压缩<br>减少 ES6 转为 ES5 的冗余代码<br>提取公共代码<br>模板预编译<br>提取组件的 CSS<br>优化 SourceMap<br>构建结果输出分析<br>Vue 项目的编译优化<br>（3）基础的 Web 技术的优化</p>
<p>开启 gzip 压缩<br>浏览器缓存<br>CDN 的使用<br>使用 Chrome Performance 查找性能瓶颈</p>
<h3 id="对于-vue3-0-特性你有什么了解的吗？"><a href="#对于-vue3-0-特性你有什么了解的吗？" class="headerlink" title="对于 vue3.0 特性你有什么了解的吗？"></a>对于 vue3.0 特性你有什么了解的吗？</h3><p>Vue 3.0 的目标是让 Vue 核心变得更小、更快、更强大，因此 Vue 3.0 增加以下这些新特性：</p>
<p>（1）监测机制的改变<br>3.0 将带来基于代理 Proxy 的 observer 实现，提供全语言覆盖的反应性跟踪。这消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制：</p>
<p>只能监测属性，不能监测对象<br>检测属性的添加和删除；<br>检测数组索引和长度的变更；<br>支持 Map、Set、WeakMap 和 WeakSet。<br>新的 observer 还提供了以下特性：</p>
<p>用于创建 observable 的公开 API。这为中小规模场景提供了简单轻量级的跨组件状态管理解决方案。<br>默认采用惰性观察。在 2.x 中，不管反应式数据有多大，都会在启动时被观察到。如果你的数据集很大，这可能会在应用启动时带来明显的开销。在 3.x 中，只观察用于渲染应用程序最初可见部分的数据。<br>更精确的变更通知。在 2.x 中，通过 Vue.set 强制添加新属性将导致依赖于该对象的 watcher 收到变更通知。在 3.x 中，只有依赖于特定属性的 watcher 才会收到通知。<br>不可变的 observable：我们可以创建值的“不可变”版本（即使是嵌套属性），除非系统在内部暂时将其“解禁”。这个机制可用于冻结 prop 传递或 Vuex 状态树以外的变化。<br>更好的调试功能：我们可以使用新的 renderTracked 和 renderTriggered 钩子精确地跟踪组件在什么时候以及为什么重新渲染。<br>（2）模板<br>模板方面没有大的变更，只改了作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。<br>同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。</p>
<p>（3）对象式的组件声明方式<br>vue2.x 中的组件是通过声明的方式传入一系列 option，和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。<br>3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 TypeScript 的结合变得很容易。<br>此外，vue 的源码也改用了 TypeScript 来写。其实当代码的功能复杂之后，必须有一个静态类型系统来做一些辅助管理。<br>现在 vue3.0 也全面改用 TypeScript 来重写了，更是使得对外暴露的 api 更容易结合 TypeScript。静态类型系统对于复杂代码的维护确实很有必要。</p>
<p>（4）其它方面的更改<br>vue3.0 的改变是全面的，上面只涉及到主要的 3 个方面，还有一些其他的更改：</p>
<p>支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。<br>支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。<br>基于 treeshaking 优化，提供了更多的内置功能。</p>
<h3 id="响应式原理（变化侦测）"><a href="#响应式原理（变化侦测）" class="headerlink" title="响应式原理（变化侦测）"></a>响应式原理（变化侦测）</h3><p>使用发布订阅模式将数据劫持和模板编译结合，实现双向绑定</p>
<p>1、observer: 封装 Object.defineProperty 方法用来劫持对象属性的getter和setter，以此来追踪数据变化。</p>
<p>2、读取数据时触发getter来收集依赖(Watcher)到Dep。<br>3、修改数据时触发setter，并遍历依赖列表，通知所有相关依赖（Watcher）<br>4、Dep 类为依赖找一个存储依赖的地方，用来收集和管理依赖，在getter中收集，在setter中通知。<br>5、Watcher 类就是收集的依赖，实际上是一个订阅器，Watcher会将自己的实例赋值给window.target（全局变量）上，然后去主动访问属性，触发属性的getter，getter中会将此Watcher收集到Dep中，Watcher的update方法会在Dep的通知方法中被调用，触发更新。<br>6、Observer 类用来将一个对象的所有属性和子属性都变成响应式的，通过递归调用defineReactive来实现。<br>7、由于无法侦测对象上新增&#x2F;删除属性，所以提供 $set 和 $delete API5。</p>
<h3 id="Object-defineProperty怎么用，-三个参数？，有什么作用啊？"><a href="#Object-defineProperty怎么用，-三个参数？，有什么作用啊？" class="headerlink" title="Object.defineProperty怎么用， 三个参数？，有什么作用啊？"></a>Object.defineProperty怎么用， 三个参数？，有什么作用啊？</h3><p>Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。</p>
<pre><code> obj：需要定义属性的对象
 prop：需要定义的属性
 &#123;&#125;：要定义或修改的属性描述符。
     value: &quot;18&quot;,         // 设置默认值 （与 get() 互斥）
     enumerable: true,    //这一句控制属性可以枚举 enumerable 改为true 就可以参与遍历了   默认值false
     writable: true,      // 该属性是否可写   默认值false （与 set() 互斥）
     configurable: true,  // 该属性是否可被删除   默认值false
      get // 当有人读取 prop 的时候  get函数就会调用,并且返回就是 sss 的值
      set // 当有人修改 prop 的时候  set函数就会调用, 有个参数这个参数就是修改后的值
</code></pre>
<h3 id="vue2和vue3的响应式原理都有什么区别呢？"><a href="#vue2和vue3的响应式原理都有什么区别呢？" class="headerlink" title="vue2和vue3的响应式原理都有什么区别呢？"></a>vue2和vue3的响应式原理都有什么区别呢？</h3><p>vue2 用的是 Object.defindProperty 但是vue3用的是Proxy</p>
<p>Object.defindProperty 缺点：</p>
<p>一次只能对一个属性进行监听，需要遍历来对所有属性监听<br>对于对象的新增属性，需要手动监听<br>对于数组通过push、unshift方法增加的元素，也无法监听<br>Proxy就没有这个问题，可以监听整个对象的数据变化，所以用vue3.0会用Proxy代替definedProperty。</p>
<h3 id="Vue的patch-diff-算法"><a href="#Vue的patch-diff-算法" class="headerlink" title="Vue的patch diff 算法"></a>Vue的patch diff 算法</h3><p>patch将新老VNode节点进行比对，然后将根据两者的比较结果进行最小单位地修改视图，而不是将整个视图根据新的VNode重绘。patch的核心在于diff算法，这套算法可以高效地比较virtual DOM的变更，得出变化以修改视图。</p>
<p>diff算法核心是通过同层的树节点进行比较而非对树进行逐层搜索遍历的方式，所以时间复杂度只有O(n)，是一种相当高效的算法。</p>
<p>同层级比较（只比较同一层级，不跨级比较）<br>tag 不相同，则直接删除重建，不在深度比较<br>tag 和 key，两个都相同，则认为是相同节点，会进行深度比较</p>
<h3 id="Vue-模板编译原理"><a href="#Vue-模板编译原理" class="headerlink" title="Vue 模板编译原理"></a>Vue 模板编译原理</h3><p>模板字符串 转换成 element AST（解析器）<br>Vue-loader 切割解析 .vue 文件（parseHTML按标签以出栈入栈形式切割（自闭合不入栈直接处理），出栈时维护父子关系）生成 AST（抽象语法树）</p>
<p>使用大量正则匹配开始结束标签，while指针定位解析位置，</p>
<p>对 AST 进行静态节点标记，主要用来做虚拟DOM的渲染优化（优化器）<br>在dom更新时不需 diff 静态节点。</p>
<p>使用 element AST 生成 render 函数代码字符串（代码生成器）<br>Vue-template-compiler再解析成render（可执行函数字符串-with(this)&#x3D;&gt;{return _c(‘div’)}），new Function 生成函数，传递给组件的 render</p>
<p>在组件渲染的时候直接调用 render 即可</p>
<h3 id="Vue原理总结"><a href="#Vue原理总结" class="headerlink" title="Vue原理总结"></a>Vue原理总结</h3><p>【模板编译】将template模板，经过编译系统后生成VNode，（模板字符串→AST→Render函数）</p>
<p>【渲染】然后再通过渲染系统来将VNode生成真实DOM（document.createElement &amp;&amp; Mount挂载到真实DOM节点上）</p>
<p>【响应式】通过响应式系统对数据进行监听，当数据发生改变时，触发依赖项（组件）</p>
<p>【Diff &amp; Patch】组件内收到通知后，会通过diff算法对比VNode的变化，尽可能复用代码，找出最小差异，保证性能消耗最小。</p>
<p>【渲染】拿到需要新增&#x2F;删除&#x2F;修改的VNode后，逐一去操作真实DOM进行修改（通过选择器选择到对应真实DOM节点进行修改）</p>
<h2 id="Webpack-篇"><a href="#Webpack-篇" class="headerlink" title="Webpack 篇"></a>Webpack 篇</h2><h3 id="谈谈你对Webpack的理解（Webpack是什么？）"><a href="#谈谈你对Webpack的理解（Webpack是什么？）" class="headerlink" title="谈谈你对Webpack的理解（Webpack是什么？）"></a>谈谈你对Webpack的理解（Webpack是什么？）</h3><p>Webpack 是一个 模块打包器，可以分析各个模块的依赖关系，最终打包成bundle静态文件（js、css、jpg）。</p>
<p>webpack 是一个静态模块打包器，当 webpack 处理应用程序时，会递归构建一个依赖关系图，其中包含应用程序需要的每个模块，然后将这些模块打包成一个或多个 bundle。</p>
<p>webpack 就像一条生产线,要经过一系列处理流程(loader)后才能将源文件转换成输出结果。 这条生产线上的每个处理流程的职责都是单一的,多个流程之间有存在依赖关系,只有完成当前处理后才能交给下一个流程去处理。<br>插件就像是一个插入到生产线中的一个功能,在特定的时机对生产线上的资源做处理。 webpack 在运行过程中会广播事件,插件只需要监听它所关心的事件,就能加入到这条生产线中,去改变生产线的运作。</p>
<h3 id="Webpack的打包过程-x2F-打包原理-x2F-构建流程？"><a href="#Webpack的打包过程-x2F-打包原理-x2F-构建流程？" class="headerlink" title="Webpack的打包过程&#x2F;打包原理&#x2F;构建流程？"></a>Webpack的打包过程&#x2F;打包原理&#x2F;构建流程？</h3><p>初始化：启动构建，读取与合并配置参数，加载plugin,实例化Compiler<br>编译：从Entry出发，针对每个Module串行调用对应的Loader去翻译文件中的内容，再找到该Module依赖的Module，递归的进行编译处理<br>输出：将编译后的Module组合成Chunk,将Chunk转换成文件，输出到文件系统中<br>细节：</p>
<p>Webpack CLI 通过 yargs模块解析 CLI 参数，并转化为配置对象option（单入口：Object，多入口：Array），调用 webpack(option) 创建 compiler 对象。</p>
<p>如果有 option.plugin，则遍历调用plugin.apply()来注册 plugin，</p>
<p>判断是否开启了 watch，如果开启则调用 compiler.watch，否则调用 compiler.run，开始构建。</p>
<p>创建 Compilation 对象来收集全部资源和信息，然后触发 make 钩子。</p>
<p>make阶段从入口开始递归所有依赖，</p>
<p>每次遍历时调用对应Loader翻译文件中内容，然后生成AST，遍历AST找到下个依赖继续递归，</p>
<p>根据入口和模块之间关系组装chunk，输出到dist中的一个文件内。</p>
<p>在以上过程中，webpack会在特定的时间点（使用tapable模块）广播特定的事件，插件监听事件并执行相应的逻辑，并且插件可以调用webpack提供的api改变webpack的运行结果</p>
<h3 id="loader的作用"><a href="#loader的作用" class="headerlink" title="loader的作用"></a>loader的作用</h3><p>webpack中的loader是一个函数，主要为了实现源码的转换，所以loader函数会以源码作为参数，比如，将ES6转换为ES5，将less转换为css，然后再将css转换为js，以便能嵌入到html文件中。</p>
<h3 id="有哪些常见的Loader？他们是解决什么问题的？"><a href="#有哪些常见的Loader？他们是解决什么问题的？" class="headerlink" title="有哪些常见的Loader？他们是解决什么问题的？"></a>有哪些常见的Loader？他们是解决什么问题的？</h3><p>file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件<br>url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去<br>source-map-loader：加载额外的 Source Map 文件，以方便断点调试<br>image-loader：加载并且压缩图片文件<br>babel-loader：把 ES6 转换成 ES5<br>css-loader：加载 CSS，支持模块化、压缩、文件导入等特性<br>style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。<br>eslint-loader：通过 ESLint 检查 JavaScript 代码</p>
<h3 id="plugin的作用"><a href="#plugin的作用" class="headerlink" title="plugin的作用"></a>plugin的作用</h3><p>plugin是一个类，类中有一个apply()方法，主要用于Plugin的安装，可以在其中监听一些来自编译器发出的事件，在合适的时机做一些事情。</p>
<h3 id="有哪些常见的Plugin？他们是解决什么问题的？"><a href="#有哪些常见的Plugin？他们是解决什么问题的？" class="headerlink" title="有哪些常见的Plugin？他们是解决什么问题的？"></a>有哪些常见的Plugin？他们是解决什么问题的？</h3><p>html-webpack-plugin：可以复制一个有结构的html文件，并自动引入打包输出的所有资源（JS&#x2F;CSS）<br>clean-webpack-plugin：重新打包自动清空 dist 目录<br>mini-css-extract-plugin：提取 js 中的 css 成单独文件<br>optimize-css-assets-webpack-plugin：压缩css<br>uglifyjs-webpack-plugin：压缩js<br>commons-chunk-plugin：提取公共代码<br>define-plugin：定义环境变量</p>
<h3 id="Webpack中Loader和Plugin的区别"><a href="#Webpack中Loader和Plugin的区别" class="headerlink" title="Webpack中Loader和Plugin的区别"></a>Webpack中Loader和Plugin的区别</h3><p>运行时机1.loader运行在编译阶段2.plugins 在整个周期都起作用</p>
<p>使用方式Loader:1.下载 2.使用Plugin:1.下载 2.引用 3.使用</p>
<h3 id="webpack的热更新是如何做到的？说明其原理？"><a href="#webpack的热更新是如何做到的？说明其原理？" class="headerlink" title="webpack的热更新是如何做到的？说明其原理？"></a>webpack的热更新是如何做到的？说明其原理？</h3><p>1、在 webpack 的 watch 模式下，文件系统中某一个文件发生修改，webpack 监听到文件变化，根据配置文件对模块重新编译打包，并将打包后的代码通过简单的 JavaScript 对象保存在内存中。<br>2、webpack-dev-server 和 webpack 之间的接口交互，而在这一步，主要是 dev-server 的中间件webpack-dev-middleware 和 webpack 之间的交互，webpack-dev-middleware 调用 webpack 暴露的 API对代码变化进行监控，并且告诉 webpack，将代码打包到内存中。<br>3、webpack-dev-server 对文件变化的一个监控，这一步不同于第一步，并不是监控代码变化重新打包。当我们在配置文件中配置了devServer.watchContentBase 为 true 的时候，Server 会监听这些配置文件夹中静态文件的变化，变化后会通知浏览器端对应用进行 live reload。注意，这儿是浏览器刷新，和 HMR 是两个概念<br>4、webpack-dev-server 代码的工作，该步骤主要是通过 sockjs（webpack-dev-server 的依赖）在浏览器端和服务端之间建立一个 websocket 长连接，将 webpack 编译打包的各个阶段的状态信息告知浏览器端，<br>同时也包括第三步中 Server 监听静态文件变化的信息。浏览器端根据这些 socket 消息进行不同的操作。当然服务端传递的最主要信息还是新模块的 hash 值，后面的步骤根据这一 hash 值来进行模块热替换。<br>webpack-dev-server&#x2F;client 端并不能够请求更新的代码，也不会执行热更模块操作，而把这些工作又交回给了 webpack，webpack&#x2F;hot&#x2F;dev-server 的工作就是根据 webpack-dev-server&#x2F;client 传给它的信息以及 dev-server 的配置决定是刷新浏览器呢还是进行模块热更新。当然如果仅仅是刷新浏览器，也就没有后面那些步骤了。HotModuleReplacement.runtime 是客户端 HMR 的中枢，它接收到上一步传递给他的新模块的 hash 值，它通过 JsonpMainTemplate.runtime 向 server 端发送 Ajax 请求，服务端返回一个 json，该 json 包含了所有要更新的模块的 hash 值，获取到更新列表后，该模块再次通过 jsonp 请求，获取到最新的模块代码。<br>5、决定 HMR 成功与否的关键步骤，在该步骤中，HotModulePlugin 将会对新旧模块进行对比，决定是否更新模块，在决定更新模块后，检查模块之间的依赖关系，更新模块的同时更新模块间的依赖引用。最后一步，当 HMR 失败后，回退到 live reload 操作，也就是进行浏览器刷新来获取最新打包代码。</p>
<h3 id="如何解决循环依赖问题"><a href="#如何解决循环依赖问题" class="headerlink" title="如何解决循环依赖问题"></a>如何解决循环依赖问题</h3><p>Webpack 中将 require 替换为 webpack_require，会根据 moduleId 到 installedModules 找是否加载过，加载过则直接返回之前的 export，不会重复加载。</p>
<h3 id="如何提高Webpack构建速度"><a href="#如何提高Webpack构建速度" class="headerlink" title="如何提高Webpack构建速度"></a>如何提高Webpack构建速度</h3><p>组件懒加载、路由懒加载、开启gzip、公共的第三方包上cdn、配置include&#x2F;exclude缩小Loader对文件的搜索范围、配置cache缓存Loader对文件的编译副本、配置resolve提高文件的搜索速度（@: src）</p>
<h2 id="性能优化篇"><a href="#性能优化篇" class="headerlink" title="性能优化篇"></a>性能优化篇</h2><h3 id="浏览器缓存优化"><a href="#浏览器缓存优化" class="headerlink" title="浏览器缓存优化"></a>浏览器缓存优化</h3><p>为了让浏览器缓存发挥最大作用，该策略尽量遵循以下五点就能发挥浏览器缓存最大作用。</p>
<p>「考虑拒绝一切缓存策略」：Cache-Control:no-store<br>「考虑资源是否每次向服务器请求」：Cache-Control:no-cache<br>「考虑资源是否被代理服务器缓存」：Cache-Control:public&#x2F;private<br>「考虑资源过期时间」：Expires:t&#x2F;Cache-Control:max-age&#x3D;t,s-maxage&#x3D;t<br>「考虑协商缓存」：Last-Modified&#x2F;Etag<br>缓存策略通过设置HTTP报文实现，在形式上分为<strong>「强缓存&#x2F;强制缓存」和「协商缓存&#x2F;对比缓存」</strong>。为了方便对比，笔者将某些细节使用图例展示，相信你有更好的理解。</p>
<p>整个缓存策略机制很明了，先走强缓存，若命中失败才走协商缓存。若命中强缓存，直接使用强缓存；若未命中强缓存，发送请求到服务器检查是否命中协商缓存；若命中协商缓存，服务器返回304通知浏览器使用本地缓存，否则返回最新资源。</p>
<p>有两种较常用的应用场景值得使用缓存策略一试，当然更多应用场景都可根据项目需求制定。</p>
<p>「频繁变动资源」：设置Cache-Control:no-cache，使浏览器每次都发送请求到服务器，配合Last-Modified&#x2F;ETag验证资源是否有效<br>「不常变化资源」：设置Cache-Control:max-age&#x3D;31536000，对文件名哈希处理，当代码修改后生成新的文件名，当HTML文件引入文件名发生改变才会下载最新文件</p>
<h3 id="渲染层面性能优化"><a href="#渲染层面性能优化" class="headerlink" title="渲染层面性能优化"></a>渲染层面性能优化</h3><p>「渲染层面」的性能优化，无疑是如何让代码解析更好执行更快。因此笔者从以下五方面做出建议。</p>
<p>「CSS策略」：基于CSS规则<br>「DOM策略」：基于DOM操作<br>「阻塞策略」：基于脚本加载<br>「回流重绘策略」：基于回流重绘<br>「异步更新策略」：基于异步更新<br>上述五方面都是编写代码时完成，充满在整个项目流程的开发阶段里。因此在开发阶段需时刻注意以下涉及到的每一点，养成良好的开发习惯，性能优化也自然而然被使用上了。</p>
<p>渲染层面的性能优化更多表现在编码细节上，而并非实体代码。简单来说就是遵循某些编码规则，才能将渲染层面的性能优化发挥到最大作用。</p>
<p>「回流重绘策略」在渲染层面的性能优化里占比较重，也是最常规的性能优化之一。上年笔者发布的掘金小册《玩转CSS的艺术之美》使用一整章讲解回流重绘，本章已开通试读，更多细节请戳这里。</p>
<p>CSS策略<br>避免出现超过三层的嵌套规则<br>避免为ID选择器添加多余选择器<br>避免使用标签选择器代替类选择器<br>避免使用通配选择器，只对目标节点声明规则<br>避免重复匹配重复定义，关注可继承属性<br>DOM策略<br>缓存DOM计算属性<br>避免过多DOM操作<br>使用DOMFragment缓存批量化DOM操作<br>阻塞策略</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">脚本与DOM/其它脚本的依赖关系很强：对&lt;script&gt;设置defer</span><br><span class="line">脚本与DOM/其它脚本的依赖关系不强：对&lt;script&gt;设置async</span><br></pre></td></tr></table></figure>
<p>回流重绘策略<br>缓存DOM计算属性<br>使用类合并样式，避免逐条改变样式<br>使用display控制DOM显隐，将DOM离线化<br>异步更新策略<br>在异步任务中修改DOM时把其包装成微任务</p>
<h3 id="性能优化六大指标"><a href="#性能优化六大指标" class="headerlink" title="性能优化六大指标"></a>性能优化六大指标</h3><p>六大指标基本囊括大部分性能优化细节，可作为九大策略的补充。笔者根据每条性能优化建议的特征将指标划分为以下六方面。</p>
<p>「加载优化」：资源在加载时可做的性能优化<br>「执行优化」：资源在执行时可做的性能优化<br>「渲染优化」：资源在渲染时可做的性能优化<br>「样式优化」：样式在编码时可做的性能优化<br>「脚本优化」：脚本在编码时可做的性能优化<br>「V8引擎优化」：针对V8引擎特征可做的性能优化</p>
<h2 id="其他杂项篇"><a href="#其他杂项篇" class="headerlink" title="其他杂项篇"></a>其他杂项篇</h2><h3 id="常见的浏览器内核有哪些？"><a href="#常见的浏览器内核有哪些？" class="headerlink" title="常见的浏览器内核有哪些？"></a>常见的浏览器内核有哪些？</h3><p>主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。<br>渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。<br>JS引擎则：解析和执行javascript来实现网页的动态效果。<br>最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。<br>常见内核<br>Trident 内核：IE, MaxThon, TT, The World, 360, 搜狗浏览器等。[又称 MSHTML]<br>Gecko 内核：Netscape6 及以上版本，FF, MozillaSuite &#x2F; SeaMonkey 等<br>Presto 内核：Opera7 及以上。 [Opera内核原为：Presto，现为：Blink;]<br>Webkit 内核：Safari, Chrome等。 [ Chrome的：Blink（WebKit 的分支）]</p>
<h3 id="网页前端性能优化的方式有哪些？"><a href="#网页前端性能优化的方式有哪些？" class="headerlink" title="网页前端性能优化的方式有哪些？"></a>网页前端性能优化的方式有哪些？</h3><p>1.压缩 css, js, 图片<br>2.减少 http 请求次数， 合并 css、js 、合并图片（雪碧图）<br>3.使用 CDN<br>4.减少 dom 元素数量<br>5.图片懒加载<br>6.静态资源另外用无 cookie 的域名<br>7.减少 dom 的访问（缓存 dom）<br>8.巧用事件委托<br>9.样式表置顶、脚本置低</p>
<h3 id="网页从输入网址到渲染完成经历了哪些过程？"><a href="#网页从输入网址到渲染完成经历了哪些过程？" class="headerlink" title="网页从输入网址到渲染完成经历了哪些过程？"></a>网页从输入网址到渲染完成经历了哪些过程？</h3><p>大致可以分为如下7步：</p>
<p>输入网址；<br>发送到DNS服务器，并获取域名对应的web服务器对应的ip地址；<br>与web服务器建立TCP连接；<br>浏览器向web服务器发送http请求；<br>web服务器响应请求，并返回指定url的数据（或错误信息，或重定向的新的url地址）；<br>浏览器下载web服务器返回的数据及解析html源文件；<br>生成DOM树，解析css和js，渲染页面，直至显示完成；</p>
<h3 id="线程与进程的区别？"><a href="#线程与进程的区别？" class="headerlink" title="线程与进程的区别？"></a>线程与进程的区别？</h3><p>一个程序至少有一个进程,一个进程至少有一个线程.<br>线程的划分尺度小于进程，使得多线程程序的并发性高。<br>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。<br>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。<br>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</p>
<h3 id="HTTP常见的状态码？"><a href="#HTTP常见的状态码？" class="headerlink" title="HTTP常见的状态码？"></a>HTTP常见的状态码？</h3><p>100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息<br>200 OK 正常返回信息<br>201 Created 请求成功并且服务器创建了新的资源<br>202 Accepted 服务器已接受请求，但尚未处理<br>301 Moved Permanently 请求的网页已永久移动到新位置。<br>302 Found 临时性重定向。<br>303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。<br>304 Not Modified 自从上次请求后，请求的网页未修改过。<br>400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。<br>401 Unauthorized 请求未授权。<br>403 Forbidden 禁止访问。<br>404 Not Found 找不到如何与 URI 相匹配的资源。<br>500 Internal Server Error 最常见的服务器端错误。<br>503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。</p>
<h3 id="图片懒加载？"><a href="#图片懒加载？" class="headerlink" title="图片懒加载？"></a>图片懒加载？</h3><p>当页面滚动的时间被触发 -&gt; 执行加载图片操作 -&gt; 判断图片是否在可视区域内 -&gt; 在，则动态将data-src的值赋予该图片</p>
<h3 id="移动端性能优化？"><a href="#移动端性能优化？" class="headerlink" title="移动端性能优化？"></a>移动端性能优化？</h3><p>尽量使用css3动画，开启硬件加速<br>适当使用touch时间代替click时间<br>避免使用css3渐变阴影效果<br>可以用transform: translateZ(0) 来开启硬件加速<br>不滥用float。float在渲染时计算量比较大，尽量减少使用<br>不滥用web字体。web字体需要下载，解析，重绘当前页面<br>合理使用requestAnimationFrame动画代替setTimeout<br>css中的属性（css3 transitions、css3 3D transforms、opacity、webGL、video）会触发GUP渲染，耗电</p>
<h3 id="TCP-传输的三次握手、四次挥手策略"><a href="#TCP-传输的三次握手、四次挥手策略" class="headerlink" title="TCP 传输的三次握手、四次挥手策略"></a>TCP 传输的三次握手、四次挥手策略</h3><p>三次握手：<br>为了准确无误地吧数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送出去后，TCP不会对传送后的情况置之不理，他一定会向对方确认是否送达，握手过程中使用TCP的标志：SYN和ACK<br>发送端首先发送一个带SYN的标志的数据包给对方<br>接收端收到后，回传一个带有SYN&#x2F;ACK标志的数据包以示传达确认信息<br>最后，发送端再回传一个带ACK的标志的数据包，代表“握手”结束<br>如在握手过程中某个阶段莫明中断，TCP协议会再次以相同的顺序发送相同的数据包<br>断开一个TCP连接需要“四次挥手”<br>第一次挥手：主动关闭方发送一个FIN，用来关注主动方到被动关闭方的数据传送，也即是主动关闭方告诫被动关闭方：我已经不会再给你发数据了（在FIN包之前发送的数据，如果没有收到对应的ACK确认报文，主动关闭方依然会重发这些数据）。但是，此时主动关闭方还可以接受数据<br>第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号收到序号 +1（与SYN相同，一个 FIN占用一个序号）<br>第三次挥手：被动关闭方发送一个 FIN。用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会给你发送数据了<br>第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手</p>
<h3 id="HTTP-和-HTTPS，为什么HTTPS安全？"><a href="#HTTP-和-HTTPS，为什么HTTPS安全？" class="headerlink" title="HTTP 和 HTTPS，为什么HTTPS安全？"></a>HTTP 和 HTTPS，为什么HTTPS安全？</h3><p>HTTP协议通常承载与 TCP协议之上，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的HTTPS<br>默认HTTP的端口号为80，HTTPS的端口号为443<br>因为网络请求需要中间有很多的服务器路由的转发，中间的节点都可能篡改信息，而如果使用HTTPS，密钥在你和终点站才有，https之所有说比http安全，是因为他利用ssl&#x2F;tls协议传输。包含证书，流量转发，负载均衡，页面适配，浏览器适配，refer传递等，保障了传输过程的安全性</p>
<h3 id="axios和fetch区别对比"><a href="#axios和fetch区别对比" class="headerlink" title="axios和fetch区别对比"></a>axios和fetch区别对比</h3><p>axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，本质上也是对原生XHR的封装，只不过它是Promise的实现版本，符合最新的ES规范，它本身具有以下特征</p>
<p>从浏览器中创建 XMLHttpRequest<br>支持 Promise API<br>客户端支持防止CSRF<br>提供了一些并发请求的接口（重要，方便了很多的操作）<br>从 node.js 创建 http 请求<br>拦截请求和响应<br>转换请求和响应数据<br>取消请求<br>自动转换JSON数据<br>fetch优势：</p>
<p>语法简洁，更加语义化<br>基于标准 Promise 实现，支持 async&#x2F;await<br>同构方便，使用 isomorphic-fetch<br>更加底层，提供的API丰富（request, response）<br>脱离了XHR，是ES规范里新的实现方式<br>fetch存在问题</p>
<p>fetch是一个低层次的API，你可以把它考虑成原生的XHR，所以使用起来并不是那么舒服，需要进行封装。<br>fetch只对网络请求报错，对400，500都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。<br>fetch默认不会带cookie，需要添加配置项： fetch(url, {credentials: ‘include’})<br>fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费<br>fetch没有办法原生监测请求的进度，而XHR可以</p>
<h2 id="主观题篇"><a href="#主观题篇" class="headerlink" title="主观题篇"></a>主观题篇</h2><h3 id="你都做过什么项目呢？具体聊某一个项目中运用的技术"><a href="#你都做过什么项目呢？具体聊某一个项目中运用的技术" class="headerlink" title="你都做过什么项目呢？具体聊某一个项目中运用的技术."></a>你都做过什么项目呢？具体聊某一个项目中运用的技术.</h3><p>注意：用心找自己做的项目中自己感觉最拿出来手的（复杂度最高，用的技术最多的项目），描述的时候尽可能往里面添加一些技术名词<br>布局我们用html5+css3<br>我们会用reset.css重置浏览器的默认样式<br>JS框架的话我们选用的是jQuery(也可能是Zepto)<br>我们用版本控制工具git来协同开发<br>我们会基于gulp搭建的前端自动化工程来开发（里面包含有我们的项目结构、我们需要引用的第三方库等一些信息，我们还实现了sass编译、CSS3加前缀等的自动化）<br>我们的项目中还用到了表单验证validate插件、图片懒加载Lazyload插件</p>
<h3 id="你遇到过比较难的技术问题是？你是如何解决的？"><a href="#你遇到过比较难的技术问题是？你是如何解决的？" class="headerlink" title="你遇到过比较难的技术问题是？你是如何解决的？"></a>你遇到过比较难的技术问题是？你是如何解决的？</h3><h3 id="常使用的库有哪些？常用的前端开发工具？开发过什么应用或组件？"><a href="#常使用的库有哪些？常用的前端开发工具？开发过什么应用或组件？" class="headerlink" title="常使用的库有哪些？常用的前端开发工具？开发过什么应用或组件？"></a>常使用的库有哪些？常用的前端开发工具？开发过什么应用或组件？</h3><h3 id="除了前端以外还了解什么其它技术么？你最最厉害的技能是什么？"><a href="#除了前端以外还了解什么其它技术么？你最最厉害的技能是什么？" class="headerlink" title="除了前端以外还了解什么其它技术么？你最最厉害的技能是什么？"></a>除了前端以外还了解什么其它技术么？你最最厉害的技能是什么？</h3><h3 id="对前端开发工程师这个职位是怎么样理解的？它的前景会怎么样？"><a href="#对前端开发工程师这个职位是怎么样理解的？它的前景会怎么样？" class="headerlink" title="对前端开发工程师这个职位是怎么样理解的？它的前景会怎么样？"></a>对前端开发工程师这个职位是怎么样理解的？它的前景会怎么样？</h3><p>前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。<br>1、实现界面交互<br>2、提升用户体验<br>3、有了Node.js，前端可以实现服务端的一些事情<br>前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好，<br>参与项目，快速高质量完成实现效果图，精确到1px；<br>与团队成员，UI设计，产品经理的沟通；<br>做好的页面结构，页面重构和用户体验；<br>处理hack，兼容、写出优美的代码格式；<br>针对服务器的优化、拥抱最新前端技术。</p>
<h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><blockquote><p>1、进程是资源分配的最小单位，线程是资源调度的最小单位。<br>2、线程是在进程下运行的。一个进程可以包含多个线程。<br>3、进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间。而线程是共享进程中的数据的，使用相同的地址空间。<br>4、同一进程下不同线程间数据容易共享，不同进程间数据很难共享。<br>5、线程之间没有单独的地址空间，一个线程死掉，整个进程也死掉。而一个进程死掉并不会对另外一个进程造成影响。</p>
</blockquote>

<h3 id="WebAssembly"><a href="#WebAssembly" class="headerlink" title="WebAssembly"></a>WebAssembly</h3><p>WebAssembly是除了 javascript以外，另一种可以在网页中运行的编程语言。<br>在这之前，如果要在浏览器种运行代码来对网页中的各种元素进行控制，只有javascript一种选择。</p>
<p>WebAssembly与其它的汇编语言不一样，它不依赖于具体的物理机器<br>可以抽象理解成它是概念机器的机器语言</p>
<p>优势</p>
<p>文件加载：WebAssembly因为是字节码所以体积比js小很多，下载速度更快<br>解析阶段：解析时间比js更短<br>编译优化：编译和优化所需的时间较少，这是因为在文件推送到服务器之前<br>已经进行了更多优化，而JavaScript需要为动态类型多次编译代码<br>重新优化：WebAssembly 代码不需要重新优化，因为编译器有足够的信息<br>可以在第一次运行时获得正确的代码<br>执行：执行可以更快，WebAssembly指令更接近机器码<br>垃圾回收：目前 WebAssembly不直接支持垃圾回收，垃圾回收都是手动控制的<br>所以比自动垃圾回收效率更高<br>安全：可以放flash和签名等等。</p>
<p>应用<br>用于视频和音频编码器，图形和3D，多媒体和游戏，密码计算或便携式语言实现等领域</p>
	  
	</div>

	<!-- recommended posts -->
	

	<div>
  	<center>
	<div class="pagination">
<ul class="pagination">
	 
				
    	<li class="prev"><a href="/2023/02/15/dotnet6/" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i>上一页</a></li>
  		

        <li><a href="/archives"><i class="fa fa-archive"></i>档案</a></li>

		
		   <li class="next"><a href="/2023/02/09/html11/" class="alignright next">下一页<i class="fa fa-arrow-circle-o-right"></i></a></li>         
        
	
</ul>
</div>

    </center>
	</div>

    <!-- share -->
    
        
    <div class="bdsharebuttonbox">
        <a href="#" class="bds_more" data-cmd="more"></a>
        <a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a>
        <a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
        <a href="#" class="bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
        <a href="#" class="bds_twi" data-cmd="twi" title="分享到Twitter"></a>
        <a href="#" class="bds_linkedin" data-cmd="linkedin" title="分享到linkedin"></a>
        <a href="#" class="bds_evernotecn" data-cmd="evernotecn" title="分享到印象笔记"></a>
        <a href="#" class="bds_youdao" data-cmd="youdao" title="分享到有道云笔记"></a>
        <a href="#" class="bds_copy" data-cmd="copy" title="分享到复制网址"></a>
    </div>
    <script>
        window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"1","bdSize":"24"},"share":{}};
        with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
    </script>


        

    
	
	<!-- comment -->
	

<!-- <section id="comment">
  <h2 class="title">留言</h2>
  
</section> -->



	
		<!-- 来必力City版安装代码 -->
<div id="lv-container" data-id="city" data-uid="MTAyMC81NzQwMS8zMzg2NQ==">
	<script type="text/javascript">
   (function(d, s) {
       var j, e = d.getElementsByTagName(s)[0];

       if (typeof LivereTower === 'function') { return; }

       j = d.createElement(s);
       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
       j.async = true;

       e.parentNode.insertBefore(j, e);
   })(document, 'script');
	</script>
<noscript> 为正常使用来必力评论功能请激活JavaScript</noscript>
</div>
<!-- City版安装代码已完成 -->
	  
	</div> <!-- col-md-9/col-md-12 -->
		
	
	<div id="side_meta">
		<div class="col-md-3" id="post_meta"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2023-02-09 
	</div>
	

	<!-- categories -->
    
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#categorys"><i class="fa fa-folder"></i></a>	
    <ul id="categorys" class="tag_box list-unstyled collapse in">
          
  <li>
    <li><a href="/categories/IT/">IT<span>89</span></a></li>
  </li>

    </ul>
	</div>
	

	<!-- tags -->
	
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#tags"><i class="fa fa-tags"></i></a>		  
    <ul id="tags" class="tag_box list-unstyled collapse in">	  
	    
  <li><a href="/tags/HTML5/">HTML5<span>19</span></a></li> <li><a href="/tags/Javascript/">Javascript<span>2</span></a></li>
    </ul>
	</div>
	

	<!-- toc -->
	<div class="meta-widget">
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->

	</div>
		

</div><!-- row -->




    </div>
  </div>
  <div class="container-narrow">
    <footer> <p>
  &copy; 2023 孑孓
  
  with help from <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/"
    target="_blank">Twitter Bootstrap</a>. Theme by <a target="_blank" rel="noopener" href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>.
</p> </footer>
  </div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>


<!-- syntax highlighting -->


</body>
</html>