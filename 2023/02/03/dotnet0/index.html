<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>.Net常用知识大全 | 月落星辰</title>
  
  <meta name="author" content="南疆">
  
  <meta name="description" content="IT技术 Vue  Hexo 前端 个人博客 干货 百科知识">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:title" content=".Net常用知识大全" />
  <meta property="og:site_name" content="月落星辰" />

  
  <meta property="og:image" content="" />
  

  

  
  <!-- <link href="/favicon.png" rel="icon"> -->
  <link rel="shortcut icon"  href="/img/favicon.ico" style="border-radius: 50%;">
  

  <!-- CSS 这个css即_config.yml 下的theme 这里是：cerulean -->
  <!-- <link rel="stylesheet" href="/css/themes/Freemind.css" media="screen" type="text/css"> -->




  <link rel="stylesheet" href="/css/highlight-default.min.css" media="screen" type="text/css">

  <link rel="stylesheet" href="/css/comment.css" media="screen" type="text/css">

  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <!-- <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css"> -->
  <link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/self-style.css" media="screen" type="text/css">


  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.9/es5-shim.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.7/es5-sham.min.js"></script>
  <![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>
  
  <!-- analytics -->
  


  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div class="container">
    <div class="content">
      


	
		<div class="page-header page-header-inverse ">		
			<h1 class="title title-inverse "> .Net常用知识大全</h1>
		</div>		
	




<!-- 不蒜子统计 -->
<div id="busuanzi_container_page_pv" class="articlenums">
	<i class="icon-smile icon"></i>文章已阅读<span id="busuanzi_value_page_pv"></span>次
</div>
<div>&nbsp;</div>



<div class="row post">
	<!-- cols -->
	
	<div id="top_meta"></div>
	<div class="col-md-9">
		

			<!-- content -->
			<div class="mypage">
				

				<h3 id="Net中所有内建类型基类是什么？"><a href="#Net中所有内建类型基类是什么？" class="headerlink" title=".Net中所有内建类型基类是什么？"></a>.Net中所有内建类型基类是什么？</h3><p>System.Object</p>
<h3 id="System-Object-中包含哪些方法，哪些是虚方法？"><a href="#System-Object-中包含哪些方法，哪些是虚方法？" class="headerlink" title="System.Object 中包含哪些方法，哪些是虚方法？"></a>System.Object 中包含哪些方法，哪些是虚方法？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">virtual bool Equals(object obj);//虚方法</span><br><span class="line">virtual int GetHashCode(object obj);//虚方法</span><br><span class="line">Type GetType();</span><br><span class="line">virtual string ToString();//虚方法</span><br><span class="line"></span><br><span class="line">//public static method</span><br><span class="line">bool Equals(object objA,object objB);</span><br><span class="line">bool RefernceEquals(object objA,object objB);</span><br><span class="line"></span><br><span class="line">//protected</span><br><span class="line">object MemberwiseClone();//浅拷贝</span><br><span class="line">Finalize();//析构方法，用于释放非托管资源</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="值类型与引用类型？"><a href="#值类型与引用类型？" class="headerlink" title="值类型与引用类型？"></a>值类型与引用类型？</h3><h3 id="ASP-NET和ASP的区别？"><a href="#ASP-NET和ASP的区别？" class="headerlink" title="ASP.NET和ASP的区别？"></a>ASP.NET和ASP的区别？</h3><p>ASP.NET和ASP的最大区别在于编程思维的转换以及功能的增强。</p>
<p>ASP使用VB&#x2F;JS这样的弱类型、面向结构的脚本语言混合html来编程，</p>
<p>而非面向对象，这就明显产生以下几个问题：</p>
<p>1、代码逻辑混乱，难于管理。</p>
<p>2、代码的可重用性差：由于是面向结构的编程方式，并且混合html，</p>
<p>所以可能页面原型修改一点，整个程序都需要修改,代码重用性差。</p>
<p>3、弱类型造成潜在的出错可能。</p>
<p>以上是ASP语言本身的弱点，在功能方面ASP同样存在问题：</p>
<p>第一是功能太弱，一些底层操作只能通过组件来完成</p>
<p>第二缺乏完善的纠错&#x2F;调试功能</p>
<p>ASP.NET理论上可以使用任何编程语言包括C#,VB.NET、JS、、J#、Managed C++等等，</p>
<p>最合适的编程语言还是MS为.NET Frmaework专门推出的C#</p>
<p>优点如下：</p>
<p>(1)是面向对象的编程语言，简单易学。</p>
<p>(2)具有面向对象编程语言的一切特性，比如封装性、继承性、多态性等等,</p>
<p>封装性使得代码逻辑清晰，并且应用到ASP.NET上就可以使业务逻辑和Html页面分离；</p>
<p>继承性和多态性使得代码的可重用性大大提高</p>
<p>(3)C#还提供了完善的调试&#x2F;纠错体系。</p>
<h3 id="为什么-NET程序第一次运行比较慢？"><a href="#为什么-NET程序第一次运行比较慢？" class="headerlink" title="为什么.NET程序第一次运行比较慢？"></a>为什么.NET程序第一次运行比较慢？</h3><p>aspx页面在运行时，第一次访问时要进行编译。</p>
<p>当你再次运行时,由于缓存机制,速度就会正常了。</p>
<h3 id="C-的命名规范"><a href="#C-的命名规范" class="headerlink" title="C#的命名规范"></a>C#的命名规范</h3><p>主要有Pascal和Camel两种</p>
<p>Pascal:单词的首字母大写,如ProductType；</p>
<p>Camel:首个单词的首字母小写，其余单词的首字母大写,如productType)</p>
<p>以下是一些常用的C#成员及其推荐命名方法：</p>
<p>类class：Pascal</p>
<p>枚举类型enum：Pascal记住，是以Pascal命名，切勿包含Enum</p>
<p>委托delegate：Pascal以Pascal命名，不以任何特殊字符串区别于类名、函数名</p>
<p>接口interface：Pascal注：总是以”I”前缀开始，后接Pascal命名</p>
<p>方法function： Pascal</p>
<p>命名空间namespace： Pascal比如：usingExcelQuicker.Framework</p>
<p>属性：Pascal</p>
<p>参数：Camel 首字母小写</p>
<p>常量const： Camel 字母全部大写</p>
<p>局部变量：Camel 声明变量是以str开头</p>
<p>数据成员：Camel 以m开头＋Pascal命名规则，如mProductType（m意味member）</p>
<h3 id="类的成员修饰符及其访问权限？"><a href="#类的成员修饰符及其访问权限？" class="headerlink" title="类的成员修饰符及其访问权限？"></a>类的成员修饰符及其访问权限？</h3><p>private : 私有成员, 在类的内部才可以访问。<br>protected : 保护成员，该类内部和继承类中可以访问。<br>public : 公共成员，完全公开，没有访问限制。<br>internal: 在同一程序集(命名空间)内可以访问。</p>
<h3 id="列举ASP-NET-页面之间传递值的几种方式。"><a href="#列举ASP-NET-页面之间传递值的几种方式。" class="headerlink" title="列举ASP.NET 页面之间传递值的几种方式。"></a>列举ASP.NET 页面之间传递值的几种方式。</h3><p>1.使用QueryString, 如…?id&#x3D;1; response. Redirect()…<br>2.使用Session变量<br>3.使用Server.Transfer<br>4.使用Cookie<br>5.使用Application</p>
<h3 id="C-中的委托是什么？事件是不是一种委托？"><a href="#C-中的委托是什么？事件是不是一种委托？" class="headerlink" title="C#中的委托是什么？事件是不是一种委托？"></a>C#中的委托是什么？事件是不是一种委托？</h3><p>委托可以把一个方法作为参数代入另一个方法。<br>委托可以理解为指向一个函数的引用。<br>事件是委托</p>
<h3 id="override与重载的区别"><a href="#override与重载的区别" class="headerlink" title="override与重载的区别"></a>override与重载的区别</h3><p>重载是方法的名称相同。参数或参数类型不同，进行多次重载以适应不同的需要<br>Override 是在子类对基类中函数的重写。为了适应需要。</p>
<h3 id="如果在一个B-x2F-S结构的系统中需要传递变量值，但是又不能使用Session、Cookie、Application，您有几种方法进行处理？"><a href="#如果在一个B-x2F-S结构的系统中需要传递变量值，但是又不能使用Session、Cookie、Application，您有几种方法进行处理？" class="headerlink" title="如果在一个B&#x2F;S结构的系统中需要传递变量值，但是又不能使用Session、Cookie、Application，您有几种方法进行处理？"></a>如果在一个B&#x2F;S结构的系统中需要传递变量值，但是又不能使用Session、Cookie、Application，您有几种方法进行处理？</h3><p>this.Server.Transfer,　　Response. Redirect()—QueryString</p>
<h3 id="描述一下C-中索引器的实现过程，是否只能根据数字进行索引？"><a href="#描述一下C-中索引器的实现过程，是否只能根据数字进行索引？" class="headerlink" title="描述一下C#中索引器的实现过程，是否只能根据数字进行索引？"></a>描述一下C#中索引器的实现过程，是否只能根据数字进行索引？</h3><p>不是。可以用任意类型。</p>
<h3 id="用-net做B-x2F-S结构的系统，您是用几层结构来开发，每一层之间的关系以及为什么要这样分层？"><a href="#用-net做B-x2F-S结构的系统，您是用几层结构来开发，每一层之间的关系以及为什么要这样分层？" class="headerlink" title="用.net做B&#x2F;S结构的系统，您是用几层结构来开发，每一层之间的关系以及为什么要这样分层？"></a>用.net做B&#x2F;S结构的系统，您是用几层结构来开发，每一层之间的关系以及为什么要这样分层？</h3><p>一般为3层:数据访问层，业务层，表示层。<br>数据访问层对数据库进行增删查改。<br>业务层一般分为二层，业务表观层实现与表示层的沟通，业务规则层实现用户密码的安全等。<br>表示层为了与用户交互例如用户添加表单。<br>优点： 分工明确，条理清晰，易于调试，而且具有可扩展性。<br>缺点： 增加成本。</p>
<h3 id="什么叫应用程序域？"><a href="#什么叫应用程序域？" class="headerlink" title="什么叫应用程序域？"></a>什么叫应用程序域？</h3><p>应用程序域可以理解为一种轻量级进程。起到安全的作用。占用资源小。</p>
<h3 id="CTS、CLS、CLR分别作何解释？"><a href="#CTS、CLS、CLR分别作何解释？" class="headerlink" title="CTS、CLS、CLR分别作何解释？"></a>CTS、CLS、CLR分别作何解释？</h3><p>CTS是通用类型系统(Common Type System)<br>CLR是公共语言运行时(Common language runtime)<br>CLS是公共语言定义(Common Language Specification)</p>
<h3 id="什么是装箱和拆箱？"><a href="#什么是装箱和拆箱？" class="headerlink" title="什么是装箱和拆箱？"></a>什么是装箱和拆箱？</h3><p>从值类型接口转换到引用类型装箱。从引用类型转换到值类型拆箱。</p>
<h3 id="什么是受管制的代码？"><a href="#什么是受管制的代码？" class="headerlink" title="什么是受管制的代码？"></a>什么是受管制的代码？</h3><p>unsafe：非托管代码。不经过CLR运行。</p>
<h3 id="什么是强类型系统？"><a href="#什么是强类型系统？" class="headerlink" title="什么是强类型系统？"></a>什么是强类型系统？</h3><p>RTTI：类型识别系统</p>
<h3 id="net中读写数据库需要用到那些类？他们的作用？"><a href="#net中读写数据库需要用到那些类？他们的作用？" class="headerlink" title="net中读写数据库需要用到那些类？他们的作用？"></a>net中读写数据库需要用到那些类？他们的作用？</h3><p>DataConnection:连接数据库<br>DataSet:数据存储器。<br>DataCommand:执行语句命令。<br>DataAdapter:数据的集合，用于填充数据。</p>
<h3 id="ASP-net的身份验证方式有哪些？分别是什么原理？"><a href="#ASP-net的身份验证方式有哪些？分别是什么原理？" class="headerlink" title="ASP.net的身份验证方式有哪些？分别是什么原理？"></a>ASP.net的身份验证方式有哪些？分别是什么原理？</h3><p>Windwos(默认)用IIS…From(窗体)用帐户…Passport(密钥)</p>
<h3 id="什么是Code-Behind技术？"><a href="#什么是Code-Behind技术？" class="headerlink" title="什么是Code-Behind技术？"></a>什么是Code-Behind技术？</h3><p>code-Behind技术就是代码隐藏（代码后置），code-Behind是基于部分类技术实现的；<br>在ASP.NET中通过ASPX页面指向CS文件的方法实现显示逻辑和处理逻辑的分离，这样有助于web应用程序的创建。<br>比如分工，美工和编程的可以个干各的，不用再像以前asp那样都代码和html代码混在一起，难以维护。</p>
<h3 id="在-net中，配件的意思是？"><a href="#在-net中，配件的意思是？" class="headerlink" title="在.net中，配件的意思是？"></a>在.net中，配件的意思是？</h3><p>程序集。（中间语言，源数据，资源，装配清单）</p>
<h3 id="常用的调用WebService的方法有哪些？"><a href="#常用的调用WebService的方法有哪些？" class="headerlink" title="常用的调用WebService的方法有哪些？"></a>常用的调用WebService的方法有哪些？</h3><p>1.使用WSDL.exe命令行工具。<br>2.使用VS.NET中的Add Web Reference菜单选项</p>
<h3 id="…net-Remoting-的工作原理是什么？"><a href="#…net-Remoting-的工作原理是什么？" class="headerlink" title="…net Remoting 的工作原理是什么？"></a>…net Remoting 的工作原理是什么？</h3><pre><code>服务器端向客户端发送一个进程编号，一个程序域编号，以确定对象的位置。
</code></pre>
<h3 id="在C＃中，string-str-x3D-null-与-string-str-x3D-“”-请尽量使用文字或图象说明其中的区别。"><a href="#在C＃中，string-str-x3D-null-与-string-str-x3D-“”-请尽量使用文字或图象说明其中的区别。" class="headerlink" title="在C＃中，string str &#x3D; null 与 string str &#x3D; “” 请尽量使用文字或图象说明其中的区别。"></a>在C＃中，string str &#x3D; null 与 string str &#x3D; “” 请尽量使用文字或图象说明其中的区别。</h3><p>string str &#x3D; null 是不给他分配内存空间,而string str &#x3D; “” 给它分配长度为空字符串的内存空间。</p>
<h3 id="请详述在dotnet中类-class-与结构-struct-的异同？"><a href="#请详述在dotnet中类-class-与结构-struct-的异同？" class="headerlink" title="请详述在dotnet中类(class)与结构(struct)的异同？"></a>请详述在dotnet中类(class)与结构(struct)的异同？</h3><p>Class可以被实例化,属于引用类型,是分配在内存的堆上的,Struct属于值类型,是分配在内存的栈上的。</p>
<h3 id="SQLSERVER服务器中，给定表-table1-中有两个字段-ID、LastUpdateDate，ID表示更新的事务号，LastUpdateDate表示更新时的服务器时间，请使用一句SQL语句获得最后更新的事务号。"><a href="#SQLSERVER服务器中，给定表-table1-中有两个字段-ID、LastUpdateDate，ID表示更新的事务号，LastUpdateDate表示更新时的服务器时间，请使用一句SQL语句获得最后更新的事务号。" class="headerlink" title="SQLSERVER服务器中，给定表 table1 中有两个字段 ID、LastUpdateDate，ID表示更新的事务号，LastUpdateDate表示更新时的服务器时间，请使用一句SQL语句获得最后更新的事务号。"></a>SQLSERVER服务器中，给定表 table1 中有两个字段 ID、LastUpdateDate，ID表示更新的事务号，LastUpdateDate表示更新时的服务器时间，请使用一句SQL语句获得最后更新的事务号。</h3><p>Select ID FROM table1 Where LastUpdateDate &#x3D; (Select MAX(LastUpdateDate) FROM table1)</p>
<h3 id="简要谈一下您对微软-NET-构架下remoting和webservice两项技术的理解以及实际中的应用。"><a href="#简要谈一下您对微软-NET-构架下remoting和webservice两项技术的理解以及实际中的应用。" class="headerlink" title="简要谈一下您对微软.NET 构架下remoting和webservice两项技术的理解以及实际中的应用。"></a>简要谈一下您对微软.NET 构架下remoting和webservice两项技术的理解以及实际中的应用。</h3><p>WS主要是可利用HTTP，穿透防火墙。而Remoting可以利用TCP&#x2F;IP，二进制传送提高效率。</p>
<h3 id="NET和C-是什么关系？"><a href="#NET和C-是什么关系？" class="headerlink" title="NET和C#是什么关系？"></a>NET和C#是什么关系？</h3><p>C#就是为宣传.NET而创立的，它直接集成于Visual Studio .NET中，VB也在.NET 1.0发布后对其进行支持， 所以这两门语言与.NET平台耦合度很高，并且.NET上的技术大多都是以C#编程语言为示例，所以经常就.NET和C#混为一谈(实质上它们是相辅相成的两个概念)。<br>而作为一个开发者平台，它不仅仅是包含开发环境、技术框架、社区论坛、服务支持等，它还强调了平台的跨语言、跨平台编程的两个特性</p>
<h3 id="列举ASP-NET-页面之间传递值的几种方式。-1"><a href="#列举ASP-NET-页面之间传递值的几种方式。-1" class="headerlink" title="列举ASP.NET 页面之间传递值的几种方式。"></a>列举ASP.NET 页面之间传递值的几种方式。</h3><p>QueryString是一种非常简单的传值方式，他可以将传送的值显示在浏览器的地址栏中。如果是传递一个或多个安全性要求不高或是结构简单的数值时，可以使用这个方法。但是对于传递数组或对象的话，就不能用这个方法了。<br>Application对象的作用范围是整个全局，也就是说对所有用户都有效。其常用的方法用Lock和UnLock。<br>Session变量 想必这个肯定是大家使用中最常见的用法了，作用于用户个人，所以，过量的存储会导致服务器内存资源的耗尽。<br>Cookie对象变量这个也是大家常使用的方法，与Session一样，其是什对每一个用户而言的，但是有个本质的区别，即Cookie是存放在客户端的，而session是存放在服务器端的。而且Cookie的使用要配合ASP.NET内置对象Request来使用。<br>Server.Transfer方法这个才可以说是面象对象开发所使用的方法，其使用Server.Transfer方法把流程从当前页面引导到另一个页面中，新的页面使用前一个页面的应答流，所以这个方法是完全面象对象的，简洁有效。</p>
<h3 id="一列数的规则如下-1、1、2、3、5、8、13、21、34……-求第30位数是多少，-用递归算法实现。"><a href="#一列数的规则如下-1、1、2、3、5、8、13、21、34……-求第30位数是多少，-用递归算法实现。" class="headerlink" title="一列数的规则如下: 1、1、2、3、5、8、13、21、34…… 求第30位数是多少， 用递归算法实现。"></a>一列数的规则如下: 1、1、2、3、5、8、13、21、34…… 求第30位数是多少， 用递归算法实现。</h3><pre><code>public static int Calculate(int x)

    &#123;

        int retInt = 1;

        if (x &gt; 2)

        &#123;

            return Calculate(x - 2) + Calculate(x - 1);

        &#125;

        else

            return retInt;

    &#125;
</code></pre>
<h3 id="C-中的委托是什么？事件是不是一种委托？-1"><a href="#C-中的委托是什么？事件是不是一种委托？-1" class="headerlink" title="C#中的委托是什么？事件是不是一种委托？"></a>C#中的委托是什么？事件是不是一种委托？</h3><p>委托是一种定义方法签名的类型，可以与具有兼容签名的任何方法关联。可以通过委</p>
<p>托调用方法。委托用于将方法作为参数传递给其他方法。</p>
<p>委托具有以下特点：</p>
<p>委托类似于 C++ 函数指针，但它们是类型安全的。<br>委托允许将方法作为参数进行传递。<br>委托可用于定义回调方法。<br>委托可以链接在一起；例如，可以对一个事件调用多个方法。<br>方法不必与委托签名完全匹配。<br>事件是一种特殊的委托。</p>
<h3 id="override与重载的区别-1"><a href="#override与重载的区别-1" class="headerlink" title="override与重载的区别"></a>override与重载的区别</h3><p>Override：要扩展或修改继承的方法、属性、索引器或事件的抽象实现或虚实现，重写的基方法必须与 override 方法具有相同的签名。</p>
<p>方法重载：一个类中可以有一个以上的方法拥有相同的名称。但必须有不相同的签名。</p>
<h3 id="如果在一个B-x2F-S结构的系统中需要传递变量值，但是又不能使用Session、Cookie、Application，您有几种方法进行处理？-1"><a href="#如果在一个B-x2F-S结构的系统中需要传递变量值，但是又不能使用Session、Cookie、Application，您有几种方法进行处理？-1" class="headerlink" title="如果在一个B&#x2F;S结构的系统中需要传递变量值，但是又不能使用Session、Cookie、Application，您有几种方法进行处理？"></a>如果在一个B&#x2F;S结构的系统中需要传递变量值，但是又不能使用Session、Cookie、Application，您有几种方法进行处理？</h3><p>QueryString、 Server.Transfer方法。</p>
<h3 id="请编程遍历页面上所有TextBox控件并给它赋值为string-Empty？"><a href="#请编程遍历页面上所有TextBox控件并给它赋值为string-Empty？" class="headerlink" title="请编程遍历页面上所有TextBox控件并给它赋值为string.Empty？"></a>请编程遍历页面上所有TextBox控件并给它赋值为string.Empty？</h3><p>foreach (Control control in this.Controls)</p>
<pre><code>        &#123;

            if (control is TextBox)

            &#123;

                TextBox tb = (TextBox)control;

                tb.Text = String.Empty;

            &#125;

        &#125;
</code></pre>
<h3 id="请编程实现一个冒泡排序算法？"><a href="#请编程实现一个冒泡排序算法？" class="headerlink" title="请编程实现一个冒泡排序算法？"></a>请编程实现一个冒泡排序算法？</h3><p>&#x2F;&#x2F;冒泡排序</p>
<pre><code>    public static void MaoPaoSort(ref int[] arrays)

    &#123;

        if (arrays != null &amp;&amp; arrays.Length &gt; 0)

        &#123;

            for (int i = 1; i &lt; arrays.Length; i++)

            &#123;

                bool isChange = false;

                for (int j = 0; j &lt; arrays.Length - i; j++)

                &#123;

                    if (arrays[j] &gt; arrays[j + 1])

                    &#123;

                        int tempValue = arrays[j];

                        arrays[j] = arrays[j + 1];

                        arrays[j + 1] = tempValue;

                        isChange = true;

                    &#125;

                &#125;

                if (!isChange)

                    break;

            &#125;

        &#125;

    &#125;
</code></pre>
<h3 id="描述一下C-中索引器的实现过程，是否只能根据数字进行索引？-1"><a href="#描述一下C-中索引器的实现过程，是否只能根据数字进行索引？-1" class="headerlink" title="描述一下C#中索引器的实现过程，是否只能根据数字进行索引？"></a>描述一下C#中索引器的实现过程，是否只能根据数字进行索引？</h3><p>索引器允许类或结构的实例就像数组一样进行索引。索引器类似于属性，不同之处在于它们的访问器采用参数。 Public ReturnType  this[ paramType  index]{get{} set{}}，可以用任何类型进行索引。</p>
<h3 id="求以下表达式的值，写出您想到的一种或几种实现方法：-1-2-3-4-……-m"><a href="#求以下表达式的值，写出您想到的一种或几种实现方法：-1-2-3-4-……-m" class="headerlink" title="求以下表达式的值，写出您想到的一种或几种实现方法： 1-2+3-4+……+m"></a>求以下表达式的值，写出您想到的一种或几种实现方法： 1-2+3-4+……+m</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public static int sumMethod1(int m)</span><br><span class="line"></span><br><span class="line">       &#123;</span><br><span class="line"></span><br><span class="line">           int <span class="built_in">sum</span>=0;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">for</span> (int i = 1; i &lt;= m; i++)</span><br><span class="line"></span><br><span class="line">           &#123;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (i % 2 != 0)</span><br><span class="line"></span><br><span class="line">                   <span class="built_in">sum</span> += i;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">                   <span class="built_in">sum</span> -= i;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="built_in">return</span> <span class="built_in">sum</span>;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       public static int sumMethod2(int m)</span><br><span class="line"></span><br><span class="line">       &#123;</span><br><span class="line"></span><br><span class="line">           int <span class="built_in">sum</span> = 0;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (m % 2 != 0)</span><br><span class="line"></span><br><span class="line">               <span class="built_in">sum</span> = m / 2 + 1;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">               <span class="built_in">sum</span> = -(m / 2);</span><br><span class="line"></span><br><span class="line">           <span class="built_in">return</span> <span class="built_in">sum</span>;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<h3 id="在下面的例子里"><a href="#在下面的例子里" class="headerlink" title="在下面的例子里"></a>在下面的例子里</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        public <span class="function"><span class="title">A</span></span>()</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            PrintFields();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public virtual void <span class="function"><span class="title">PrintFields</span></span>() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    class B : A</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        int x = 1;</span><br><span class="line"></span><br><span class="line">        int y;</span><br><span class="line"></span><br><span class="line">        public <span class="function"><span class="title">B</span></span>()</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            y = -1;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public override void <span class="function"><span class="title">PrintFields</span></span>()</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;x=&#123;0&#125;,y=&#123;1&#125;&quot;</span>, x, y);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>当使用new B()创建B的实例时，产生什么输出？</p>
<p>X&#x3D;1,Y&#x3D;0</p>
<h3 id="什么叫应用程序域？-1"><a href="#什么叫应用程序域？-1" class="headerlink" title="什么叫应用程序域？"></a>什么叫应用程序域？</h3><p>应用程序域 (application domain) (AppDomain) 一种边界，它由公共语言运行库围绕同一应用程序范围内创建的对象建立（即，从应用程序入口点开始，沿着对象激活的序列的任何位置）。应用程序域有助于将在一个应用程序中创建的对象与在其他应用程序中创建的对象隔离，以使运行时行为可以预知。在一个单独的进程中可以存在多个应用程序域</p>
<h3 id="CTS、CLS、CLR分别作何解释？-1"><a href="#CTS、CLS、CLR分别作何解释？-1" class="headerlink" title="CTS、CLS、CLR分别作何解释？"></a>CTS、CLS、CLR分别作何解释？</h3><p>CTS：通用类型系统。CLS：通用语言规范。CLR：公共语言运行库。</p>
<h3 id="什么是装箱和拆箱？-1"><a href="#什么是装箱和拆箱？-1" class="headerlink" title="什么是装箱和拆箱？"></a>什么是装箱和拆箱？</h3><p>装箱：装箱转换是指将一个值类型隐式或显式地转换成一个object类型，拆箱：拆箱转换是指将一个对象类型显式地转换成一个值类型。</p>
<h3 id="什么是受管制的代码？-1"><a href="#什么是受管制的代码？-1" class="headerlink" title="什么是受管制的代码？"></a>什么是受管制的代码？</h3><p>受托管的代码不能直接写内存，是安全的，它受CLR的内存安全管理，而非托管代码是非安全代码，可以使用指针操作内存</p>
<h3 id="net中读写数据库需要用到那些类？他们的作用？-1"><a href="#net中读写数据库需要用到那些类？他们的作用？-1" class="headerlink" title="net中读写数据库需要用到那些类？他们的作用？"></a>net中读写数据库需要用到那些类？他们的作用？</h3><p>DataSet:数据存储器</p>
<p>Connection对象，用来创建和打开，关闭数据库连接。</p>
<p>Command对象，用来执行各种sql语句或者调用存储过程。</p>
<p>Adapter对象，数据适配器，用来执行SQL语句，配合数据集执行比较多。</p>
<p>DataReader，只读的对象，有着很高的性能。</p>
<h3 id="在-net中，配件的意思是？-1"><a href="#在-net中，配件的意思是？-1" class="headerlink" title="在.net中，配件的意思是？"></a>在.net中，配件的意思是？</h3><p>程序集。（中间语言，源数据，资源，装配清单）</p>
<h3 id="常用的调用WebService的方法有哪些？-1"><a href="#常用的调用WebService的方法有哪些？-1" class="headerlink" title="常用的调用WebService的方法有哪些？"></a>常用的调用WebService的方法有哪些？</h3><p>1.使用WSDL.exe命令行工具。</p>
<pre><code> 2.使用VS.NET中的Add Web Reference菜单选项
</code></pre>
<h3 id="net-Remoting-的工作原理是什么？"><a href="#net-Remoting-的工作原理是什么？" class="headerlink" title=".net Remoting 的工作原理是什么？"></a>.net Remoting 的工作原理是什么？</h3><p>服务器端向客户端发送一个进程编号，一个程序域编号，以确定对象的位置。</p>
<h3 id="公司要求开发一个继承System-Windows-Forms-ListView类的组件，要求达到以下的特殊功能：点击ListView-各列列头时，能按照点击列的每行值进行重排视图中的所有行-排序的方式如DataGrid相似-。根据您的知识，请简要谈一下您的思路"><a href="#公司要求开发一个继承System-Windows-Forms-ListView类的组件，要求达到以下的特殊功能：点击ListView-各列列头时，能按照点击列的每行值进行重排视图中的所有行-排序的方式如DataGrid相似-。根据您的知识，请简要谈一下您的思路" class="headerlink" title="公司要求开发一个继承System.Windows.Forms.ListView类的组件，要求达到以下的特殊功能：点击ListView 各列列头时，能按照点击列的每行值进行重排视图中的所有行 (排序的方式如DataGrid相似)。根据您的知识，请简要谈一下您的思路"></a>公司要求开发一个继承System.Windows.Forms.ListView类的组件，要求达到以下的特殊功能：点击ListView 各列列头时，能按照点击列的每行值进行重排视图中的所有行 (排序的方式如DataGrid相似)。根据您的知识，请简要谈一下您的思路</h3><p>根据点击的列头,包该列的名称取出,按照该列名排序后,再绑定到ListView中。</p>
<h3 id="能用foreach遍历访问的对象需要实现IEnumerable接口或声明GetEnumerator方法的类型。"><a href="#能用foreach遍历访问的对象需要实现IEnumerable接口或声明GetEnumerator方法的类型。" class="headerlink" title="能用foreach遍历访问的对象需要实现IEnumerable接口或声明GetEnumerator方法的类型。"></a>能用foreach遍历访问的对象需要实现IEnumerable接口或声明GetEnumerator方法的类型。</h3><h3 id="GC是什么-为什么要有GC"><a href="#GC是什么-为什么要有GC" class="headerlink" title="GC是什么? 为什么要有GC?"></a>GC是什么? 为什么要有GC?</h3><p>GC是垃圾收集器。程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一： System.GC.Collect()；</p>
<h3 id="String-s-x3D-new-String-“xyz”-创建了几个String-Object"><a href="#String-s-x3D-new-String-“xyz”-创建了几个String-Object" class="headerlink" title="String s &#x3D; new String(“xyz”);创建了几个String Object?"></a>String s &#x3D; new String(“xyz”);创建了几个String Object?</h3><p>两个对象，一个是“xyx”,一个是指向“xyx”的引用对像s。</p>
<h3 id="abstract-class和interface有什么区别"><a href="#abstract-class和interface有什么区别" class="headerlink" title="abstract class和interface有什么区别?"></a>abstract class和interface有什么区别?</h3><p>抽象类：</p>
<p>只能用做其它类的基类，它就是被设计来被继承的。<br>不能创建它的实例。<br>它使用abstract修饰符来声明。<br>抽象类可以包含抽象成员，但不是必须的，它的成员可以抽象成员和普通带实现的成员的任意组合。<br>它自己可以派生自另一个抽象类。任何派生自抽象类的类必须使用override关键字实现该类所有的抽象成员，除非派生类自己也是抽象类。<br>接口：</p>
<p>接口是表示一组函数成员而不实现成员的引用类型。其它类和结构可以实现接口。<br>接口声明不包括数据成员。<br>接口声明只能包含如下类型的静态成员函数的声明：方法、属性、事件、索引。<br>接口的成员不能包含任何实现代码，而在每一个成员声明的主体后必须使用分号。<br>接口名称必须从大写的I开始。它和类一样，也可以声明成分部接口。<br>接口声明可以有任何的访问类型：public、protected、internal、private。<br>接口成员是隐式Public的，不允许有任何访问修饰符。<br>1， 什么是线程池</p>
<p>为了帮我们降低创建和销毁线程相关的成本，CLR为每一个进程维护了一个线程池。一开始进程的线程池是空的，如果进程使用的线程被创建，并且完成了线程的执行，它不会被销毁，而是加入到进程的线程池中，这后，如果进程需要一个另外一个线程，CLR就会从池中还原一个线程，这就节省了很多时间。</p>
<h3 id="启动一个线程是用run-还是start"><a href="#启动一个线程是用run-还是start" class="headerlink" title="启动一个线程是用run()还是start()?"></a>启动一个线程是用run()还是start()?</h3><p>启动一个线程是调用start()方法，这并不意味着线程就会立即运行，只是进入了可运行状态。直接调用run()方法不会产生线程，而是把它当作普通的方法调用，马上执行</p>
<h3 id="接口是否可继承接口-抽像类是否可实现-implements-接口-抽像类是否可继承实体类-concrete-class"><a href="#接口是否可继承接口-抽像类是否可实现-implements-接口-抽像类是否可继承实体类-concrete-class" class="headerlink" title="接口是否可继承接口? 抽像类是否可实现(implements)接口? 抽像类是否可继承实体类(concrete class)?"></a>接口是否可继承接口? 抽像类是否可实现(implements)接口? 抽像类是否可继承实体类(concrete class)?</h3><p>接口可以继承接口。抽像类可以实现(implements)接口，抽像类是否可继承实体类，但前提是实体类必须有明确的构造函数。</p>
<h3 id="构造器Constructor是否可被override"><a href="#构造器Constructor是否可被override" class="headerlink" title="构造器Constructor是否可被override?"></a>构造器Constructor是否可被override?</h3><p>构造器Constructor不能被继承，因此不能重写Override，但可以被重载Overload。</p>
<p>Constructor不能被继承，所以Constructor也就不能被override。每一个类必须有自己的构造函数，负责构造自己这部分的构造。子类不会覆盖父类的构造函数，相反必须负责在一开始调用父类的构造函数。</p>
<h3 id="是否可以继承String类"><a href="#是否可以继承String类" class="headerlink" title="是否可以继承String类?"></a>是否可以继承String类?</h3><p>不可以，因为String类是密封类，被Sealed修饰符所修饰。</p>
<h3 id="两个对像值相同-x-equals-y-x3D-x3D-true-，但却可有不同的hash-code，这句话对不对"><a href="#两个对像值相同-x-equals-y-x3D-x3D-true-，但却可有不同的hash-code，这句话对不对" class="headerlink" title="两个对像值相同(x.equals(y) &#x3D;&#x3D; true)，但却可有不同的hash code，这句话对不对?"></a>两个对像值相同(x.equals(y) &#x3D;&#x3D; true)，但却可有不同的hash code，这句话对不对?</h3><p>不对，有相同的hash code。</p>
<p>Hash Code:可以简单的理解为内存的地址。</p>
<p>“&#x3D;&#x3D;” : 操作比较的是两个变量的值是否相等，对于引用型变量表示的是两个变量在堆中存储</p>
<p>的地址是否相同，即栈中的内容是否相同。</p>
<p>“equals” : 操作表示的两个变量是否是对同一个对象的引用，即堆中的内容是否相同。</p>
<p>而字符串是一个特殊的引用型类型，在C#语言中，重载了string 对象的很多方法方法(包括equals()方法)，使string对象用起来就像是值类型一样。</p>
<h3 id="swtich是否能作用在byte上，是否能作用在long上，是否能作用在String上"><a href="#swtich是否能作用在byte上，是否能作用在long上，是否能作用在String上" class="headerlink" title="swtich是否能作用在byte上，是否能作用在long上，是否能作用在String上?"></a>swtich是否能作用在byte上，是否能作用在long上，是否能作用在String上?</h3><p>可以。</p>
<h3 id="当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法"><a href="#当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法" class="headerlink" title="当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?"></a>当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?</h3><p>不能，一个对象的一个synchronized方法只能由一个线程访问。</p>
<h3 id="List-Set-Map是否继承自Collection接口"><a href="#List-Set-Map是否继承自Collection接口" class="headerlink" title="List, Set, Map是否继承自Collection接口?"></a>List, Set, Map是否继承自Collection接口?</h3><p>List，Set是Map不是</p>
<h3 id="数组有没有length-这个方法-String有没有length-这个方法？"><a href="#数组有没有length-这个方法-String有没有length-这个方法？" class="headerlink" title="数组有没有length()这个方法? String有没有length()这个方法？"></a>数组有没有length()这个方法? String有没有length()这个方法？</h3><p>数组和string都没有Length()方法，只有Length属性。</p>
<h3 id="sleep-和-wait-有什么区别"><a href="#sleep-和-wait-有什么区别" class="headerlink" title="sleep() 和 wait() 有什么区别?"></a>sleep() 和 wait() 有什么区别?</h3><p>sleep()方法是将当前线程挂起指定的时间。</p>
<p>wait()释放对象上的锁并阻塞当前线程，直到它重新获取该锁。</p>
<h3 id="short-s1-x3D-1-s1-x3D-s1-1-有什么错-short-s1-x3D-1-s1-x3D-1-有什么错"><a href="#short-s1-x3D-1-s1-x3D-s1-1-有什么错-short-s1-x3D-1-s1-x3D-1-有什么错" class="headerlink" title="short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有什么错? short s1 &#x3D; 1; s1 +&#x3D; 1;有什么错?"></a>short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有什么错? short s1 &#x3D; 1; s1 +&#x3D; 1;有什么错?</h3><p>short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有错，s1是short型，s1+1是int型,不能隐式转化为short型。可修改为s1 &#x3D;(short)(s1 + 1) 。short s1 &#x3D; 1; s1 +&#x3D; 1正确。</p>
<p>复合赋值表达式自动地将所执行计算的结果转型为其左侧变量的类型，s1+&#x3D;1等价于s1&#x3D;(short)s1+1；</p>
<h3 id="如何处理几十万条并发数据？"><a href="#如何处理几十万条并发数据？" class="headerlink" title="如何处理几十万条并发数据？"></a>如何处理几十万条并发数据？</h3><p>用存储过程或事务。取得最大标识的时候同时更新..注意主键不是自增量方式这种方法并发的时候是不会有重复主键的..取得最大标识要有一个存储过程来获取.</p>
<h3 id="Session有什么重大BUG，微软提出了什么方法加以解决？"><a href="#Session有什么重大BUG，微软提出了什么方法加以解决？" class="headerlink" title="Session有什么重大BUG，微软提出了什么方法加以解决？"></a>Session有什么重大BUG，微软提出了什么方法加以解决？</h3><p>是iis中由于有进程回收机制，系统繁忙的话Session会丢失，可以用Sate server或SQL Server数据库的方式存储Session不过这种方式比较慢，而且无法捕获Session的END事件。</p>
<h3 id="进程和线程的区别？"><a href="#进程和线程的区别？" class="headerlink" title="进程和线程的区别？"></a>进程和线程的区别？</h3><p>进程是系统进行资源分配和调度的单位；线程是CPU调度和分派的单位，一个进程可以有多个线程，这些线程共享这个进程的资源。</p>
<p>进程：进程就是一组资源，它们构成了一个正在运行的程序。</p>
<p>线程：在进程中系统创建了一个叫做线程的内核对象，线程体现了一个程序的真实执行情况。</p>
<h3 id="堆和栈的区别？"><a href="#堆和栈的区别？" class="headerlink" title="堆和栈的区别？"></a>堆和栈的区别？</h3><p>栈是编译期间就分配好的内存空间，因此你的代码中必须就栈的大小有明确的定义；堆是程序运行期间动态分配的内存空间，你可以根据程序的运行情况确定要分配的堆内存的大小。</p>
<p>栈：它是一个内存数组，是一个LIFO的数据结构，数据只能从栈顶插入和删除。</p>
<p>堆：它是一块内存区域，在堆里可以分配大块的内存用于存储某类型的数据，堆里的内存可以以任意顺序存入和取出。</p>
<h3 id="成员变量和成员函数前加static的作用？"><a href="#成员变量和成员函数前加static的作用？" class="headerlink" title="成员变量和成员函数前加static的作用？"></a>成员变量和成员函数前加static的作用？</h3><p>它们用来反映类的状态。<br>静态成员它被类的所有实例所共享，所有实例都访问同一内存位置。<br>它们独立于所有的类实例，即使没有类实例，也可以调用类的静态成员。</p>
<h3 id="ASP-NET与ASP相比，主要有哪些进步？"><a href="#ASP-NET与ASP相比，主要有哪些进步？" class="headerlink" title="ASP.NET与ASP相比，主要有哪些进步？"></a>ASP.NET与ASP相比，主要有哪些进步？</h3><p>asp解释形，aspx编译型，性能提高，可以跟美工的工作分开进行，更有利于团队开发。</p>
<h3 id="产生一个int数组，长度为100，并向其中随机插入1-100，并且不能重复。"><a href="#产生一个int数组，长度为100，并向其中随机插入1-100，并且不能重复。" class="headerlink" title="产生一个int数组，长度为100，并向其中随机插入1-100，并且不能重复。"></a>产生一个int数组，长度为100，并向其中随机插入1-100，并且不能重复。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public static int[] <span class="function"><span class="title">BuildIntArray</span></span>()</span><br><span class="line"></span><br><span class="line">         &#123;</span><br><span class="line"></span><br><span class="line">            int[] retsInt = new int[100];</span><br><span class="line"></span><br><span class="line">            List&lt;int&gt; tempList = new List&lt;int&gt;();</span><br><span class="line"></span><br><span class="line">            Random random = new Random();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(tempList.Count &lt; 100)</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                int num = random.Next(1, 101);</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (!tempList.Contains(num))</span><br><span class="line"></span><br><span class="line">                   tempList.Add(num);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            tempList.Sort();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (int i = 0; i &lt; tempList.Count; i++)</span><br><span class="line"></span><br><span class="line">                retsInt[i] = tempList[i];</span><br><span class="line"></span><br><span class="line">            <span class="built_in">return</span> retsInt;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="请说明在-net中常用的几种页面间传递参数的方法，并说出他们的优缺点。"><a href="#请说明在-net中常用的几种页面间传递参数的方法，并说出他们的优缺点。" class="headerlink" title="请说明在.net中常用的几种页面间传递参数的方法，并说出他们的优缺点。"></a>请说明在.net中常用的几种页面间传递参数的方法，并说出他们的优缺点。</h3><p>QueryString  传递一个或多个安全性要求不高或是结构简单的数值。但是对于传递数组或对象的话，就不能用这个方法了<br>session(viewstate) 简单，但易丢失 作用于用户个人,过量的存储会导致服务器内存资源的耗尽。<br>application 对象的作用范围是整个全局，也就是说对所有用户都有效。其常用的方法用Lock和UnLock<br>cookie 简单，但可能不支持，可能被伪造 Cookie是存放在客户端的，而session是存放在服务器端的。而且Cookie的使用要配合ASP.NET内置对象Request来使用<br>input ttype&#x3D;”hidden” 简单，可能被伪造<br>url参数简单，显示于地址栏，长度有限<br>Server.Transfer  把流程从当前页面引导到另一个页面中，新的页面使用前一个页面的应答流<br>数据库稳定，安全，但性能相对弱</p>
<h3 id="请指出GAC的含义？"><a href="#请指出GAC的含义？" class="headerlink" title="请指出GAC的含义？"></a>请指出GAC的含义？</h3><p>全局程序集缓存。</p>
<p>GAC（Global  Assembly Cache），他的作用是可以存放一些有很多程序都要用到的公共Assembly。这样，很多程序就可以从GAC里面取得Assembly，而不需要再把所有要用到的Assembly都拷贝到应用程序的执行目录下面。</p>
<h3 id="向服务器发送请求有几种方式？"><a href="#向服务器发送请求有几种方式？" class="headerlink" title="向服务器发送请求有几种方式？"></a>向服务器发送请求有几种方式？</h3><p>get,post。get一般为链接方式，post一般为按钮方式。</p>
<p>区别：</p>
<pre><code>  Get 方式， 服务器端用Request.Qurystring取变量的值，安全性不高，传送数据量小。
  post方式，服务器端用Request.Form获取提交的数据，安全性高。
</code></pre>
<p>建议：</p>
<p>1、get方式的安全性较Post方式要差些，包含机密信息的话，建议用Post数据提交方式；</p>
<p>2、在做数据查询时，建议用Get方式；而在做数据添加、修改或删除时，建议用Post方式。</p>
<h3 id="DataReader与Dataset有什么区别？"><a href="#DataReader与Dataset有什么区别？" class="headerlink" title="DataReader与Dataset有什么区别？"></a>DataReader与Dataset有什么区别？</h3><p>连接数据库时DataSet是非面向连接的，而DataReader是面向连接的。<br>DataSet表示一个数据集，是数据在内存中的缓存，可以包括多个表，是保存数据的数据结构。而Datareader不承担保存数据的责任，它只负责从数据源读取数据到本地而已，它不是数据结构，而是网络通讯组件的高层封装。<br>DataSet可以离线处理，前后滚动，而DataReader不能离线处理，且是只读向前的，速度快。<br>DataSet可以存储数据库各种对象的，比如表触发器等，可以更新回原来的数据库。而DataReader只能存储游标记录，不可以更新回原来的数据库， 它类似一个只能向前的游标记录集。</p>
<h3 id="软件开发过程一般有几个阶段？每个阶段的作用？"><a href="#软件开发过程一般有几个阶段？每个阶段的作用？" class="headerlink" title="软件开发过程一般有几个阶段？每个阶段的作用？"></a>软件开发过程一般有几个阶段？每个阶段的作用？</h3><p>软件开发一般分为五个阶段：</p>
<p>问题的定义及规划<br>此阶段是软件开发与需求方共同讨论，主要确定软件的开发目标及其可行性。</p>
<p>需求分析<br>在确定软件开发可行性的情况下，对软件需要实现的各个功能进行详细需求分析。需求分析阶段是一个很重要的阶段，这一阶段做的好，将为整个软件项目的开发打下良好的基础。“唯一不变的是变化本身”，同样软件需求也是在软件开发过程中不断变化和深入的，因此，我们必须定制需求变更计划来应付这种变化，以保护整个项目的正常进行。</p>
<p>软件设计<br>此阶段中要根据需求分析的结果，对整个软件系统进行设计，如系统框架设计、数据库设计等。软件设计一般分为概要设计和详细设计，软件设计将为软件程序编写打下良好的基础。</p>
<p>程序编码<br>此阶段是将软件设计的结果转化为计算机可运行的程序代码。在程序编码中必定要制定统一、符合标准的编写规范。以保证程序的可读性、易维护性。提高程序的运行效率。</p>
<p>软件测试<br>在软件设计完成之后要进行严密的测试，一发现软件在整个软件设计过程中存在的问题并加以纠正。整个测试阶段分为单元测试、组装测试、系统测试三个阶段进行。测试方法主要有白盒测试和黑盒测试。</p>
<h3 id="在c-中using和new这两个关键字有什么意义，请写出你所知道的意义？"><a href="#在c-中using和new这两个关键字有什么意义，请写出你所知道的意义？" class="headerlink" title="在c#中using和new这两个关键字有什么意义，请写出你所知道的意义？"></a>在c#中using和new这两个关键字有什么意义，请写出你所知道的意义？</h3><p>Uning:<br>using做为命名空间指令：通过在源文件顶端放置Using命名空间指令以避免不得不使用长名称，它通知编译器你将要使用来自某个指定命名空间的类型。<br>using做为别名指令：它允许对一个命名空间或命名空间中的一个类型起一个别名。<br>using语句：某些类型的非托管对象有数量限制或很耗费系统资源，这样在代码使用完它们后，就得尽可能快的释放它们，using语句有助于简化该过程并确保这些资源被适当的处置。</p>
<p>New :<br>创建类和结构的实例。<br>隐藏基类的方法。<br>创建匿名类型（var和new关键字一起使用时可以创建匿名类型，匿名类型只是一个继承了Object的、没有名称的类，该类的定义从初始化器中推断，类似于隐匿类型化的变量）。</p>
<h3 id="需要实现对一个字符串的处理-首先将该字符串首尾的空格去掉-如果字符串中间还有连续空格的话-仅保留一个空格-即允许字符串中间有多个空格-但连续的空格数不可超过一个"><a href="#需要实现对一个字符串的处理-首先将该字符串首尾的空格去掉-如果字符串中间还有连续空格的话-仅保留一个空格-即允许字符串中间有多个空格-但连续的空格数不可超过一个" class="headerlink" title="需要实现对一个字符串的处理,首先将该字符串首尾的空格去掉,如果字符串中间还有连续空格的话,仅保留一个空格,即允许字符串中间有多个空格,但连续的空格数不可超过一个."></a>需要实现对一个字符串的处理,首先将该字符串首尾的空格去掉,如果字符串中间还有连续空格的话,仅保留一个空格,即允许字符串中间有多个空格,但连续的空格数不可超过一个.</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    string str = <span class="string">&quot;  afdkd   askdfji  ksdafj   &quot;</span>;</span><br><span class="line">    string strAfter = Regex.Replace(str.Trim(), @<span class="string">&quot;\s+&quot;</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line"><span class="comment">### 下面这段代码输出什么？为什么？</span></span><br><span class="line">```bash</span><br><span class="line">int i = 5;</span><br><span class="line"></span><br><span class="line">            int j = 5;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (Object.ReferenceEquals(i, j))</span><br><span class="line"></span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Equal&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Not Equal&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>Not Equal，因为ReferenceEquals是Object的静态方法，用于比较两个引用类型的对象是否是对于同一个对象的引用，对于值类型它总是返回false。</p>
<h3 id="ReferenceEquals-x3D-x3D-Equals的区别"><a href="#ReferenceEquals-x3D-x3D-Equals的区别" class="headerlink" title="ReferenceEquals, &#x3D;&#x3D; , Equals的区别"></a>ReferenceEquals, &#x3D;&#x3D; , Equals的区别</h3><p>String对于声明的相同的字符串在堆上只保留一个Copy，所以有相同字符串值的两个字符串变量将会指向相同的Reference。<br>ReferenceEquals：<br>它是Object的静态方法，用于比较两个引用类型的对象是否是对于同一个对象的引用，对于值类型它总是返回false。<br>&#x3D;&#x3D;：<br>它是一个可以重载的二元操作符,可以用于比较两个对象是否相等。<br>对于内置值类型，&#x3D;&#x3D;判断的是两个对象的代数值是否相等。它会根据需要自动进行必要的类型转换，并根据两个对象的值是否相等返回true或者false，而对于用户定义的值类型，如果没有重载&#x3D;&#x3D;操作符，&#x3D;&#x3D;将是不能够使用的。<br>对于引用类型，&#x3D;&#x3D; 默认的行为与ReferenceEquals的行为相同，仅有两个对象指向同一个Reference的时候才返回true。但是.NET Framework中的类很多对&#x3D;&#x3D;进行了重载，例如String类的&#x3D;&#x3D;与Equals的行为相同，判断两个字符串的内容是否相等。所以在应用中，对于 系统定义的引用类型建议不要使用&#x3D;&#x3D;操作符，以免程序出现与预期不同的运行结果。<br>Equals():<br>它对于值类型和引用类型的定义不同，对于值类型，类型相同，并且数值相同(对于struct的每个成员都必须相同)，则Equals返回 true,否则返回false。而对于引用类型，默认的行为与ReferenceEquals的行为相同，仅有两个对象指向同一个Reference的时 候才返回true。可以根据需要对Equals进行重载，例如String类的Equals用于判断两个字符串的内容是否相等。</p>
<h3 id="什么叫做SQL注入，如何防止？请举例说明。"><a href="#什么叫做SQL注入，如何防止？请举例说明。" class="headerlink" title="什么叫做SQL注入，如何防止？请举例说明。"></a>什么叫做SQL注入，如何防止？请举例说明。</h3><p>利用sql语言漏洞获得合法身份登陆系统。如身份验证的程序设计成：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SqlCommand com=new SqlCommand(<span class="string">&quot;Select * from users where username=&#x27;&quot;</span>+t_name.text+<span class="string">&quot;&#x27; and pwd=&#x27;&quot;</span>+t_pwd.text+<span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line"></span><br><span class="line">object obj=com.ExcuteScale();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(obj!=null)</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    //通过验证</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这段代码容易被sql注入。如用户在t_name中随便输入，在t_pwd中输入1’ or 1&#x3D;’1  就可以进入系统了。可以采用参数化查询语句进行防止。</p>
<h3 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h3><p>有关程序及其类型的数据被称为元数据（metadata），它们保存在程序的程序集中。程序在运行时，可以查看其它程序集及其本身的元数据，一个运行的程序查看本身及其它程序集的元数据的行为叫做反射（reflection）。</p>
<h3 id="用Singleton如何写设计模式"><a href="#用Singleton如何写设计模式" class="headerlink" title="用Singleton如何写设计模式"></a>用Singleton如何写设计模式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line">public sealed class Sun</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        private static Sun instance = null;</span><br><span class="line"></span><br><span class="line">        private <span class="function"><span class="title">Sun</span></span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">        public static Sun Instance</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            get</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">return</span> instance == null ? instance = new Sun() : instance;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line"><span class="comment">### 什么是Application Pool？</span></span><br><span class="line"></span><br><span class="line">Web应用，类似Thread Pool，提高并发性能。</span><br><span class="line"></span><br><span class="line"><span class="comment">### 什么是虚函数？什么是抽像函数？</span></span><br><span class="line"></span><br><span class="line">虚函数：使它们可以在派生类中被重写，它自身可以有函数的实现。</span><br><span class="line">抽像函数：规定其非虚子类必须实现的函数，必须被重写，它自身不可有函数的实现</span><br><span class="line"><span class="comment">### 什么是XML？</span></span><br><span class="line"></span><br><span class="line">XML即可扩展标记语言（Extensible Markup Language）。它是一种以简单文本格式存储数据的方式，这意味着它可以被任何计算机读取，它在.Net中执行大量的任务，包括描述应用程序的配置、在Web服务之间传输信息等。</span><br><span class="line"></span><br><span class="line"><span class="comment">### 什么是ASP.net中的用户控件？</span></span><br><span class="line"></span><br><span class="line">用户控件是能够在其中放置标记和 Web 服务器控件的容器。然后，可以将用户控件作为一个单元对待，为其定义属性和方法。有了用户控件，就不必为每个需要相同内容的页面多次创建用户界面，编写代码，而只需要创建一个用户控件，在几个页面中多次使用。</span><br><span class="line"></span><br><span class="line"><span class="comment">### 列举一下你所了解的XML技术及其应用</span></span><br><span class="line"></span><br><span class="line">xml用于配置,用于保存静态数据类型.接触XML最多的是web Services..和config,soap协议</span><br><span class="line"></span><br><span class="line"><span class="comment">### ADO.net中常用的对象有哪些？分别描述一下。</span></span><br><span class="line"></span><br><span class="line">提供者对象：</span><br><span class="line"></span><br><span class="line">Connection 提供到数据源的基本连接。</span><br><span class="line">Command 使用它对数据源发出命令。</span><br><span class="line">CommandBuilder 此对象用于构建Sql命令，在基于单一表查询的对象中进行数据修改。</span><br><span class="line">DataReader 这是一个快速而易用的对象，可以从数据源中读取仅能前向和只读的数据流。</span><br><span class="line">DataAdapter 它是一个通用的类，可以执行针对数据源的各种操作，包括更新变动的数据，填充DataSet对象以及其它操作。</span><br><span class="line">用户对象：</span><br><span class="line"></span><br><span class="line">DataSet 它表示一组相关表，在应用程序中这些表作为一个单元来引用。</span><br><span class="line"></span><br><span class="line"><span class="comment">### 什么是code-Behind技术。</span></span><br><span class="line"></span><br><span class="line">Code-Behind技术也称为代码隐藏技术，在ASP.NET中通过ASPX页面指向CS文件的方法实现显示逻辑和处理逻辑的分离，这样有助于web应用程序的创建。比如分工，美工和编程的可以个干各的，不用再像以前asp那样都代码和html代码混在一起，难以维护。 </span><br><span class="line"></span><br><span class="line"><span class="comment">### 什么是SOAP,有哪些应用。</span></span><br><span class="line"></span><br><span class="line">答:SOAP（Simple Object Access Protocol ）简单对象访问协议，是在分散或分布式的环境中交换信息并执行远程过程调用的协议，是一个基于XML的协议。使用SOAP，不用考虑任何特定的传输协议（最常用的还是HTTP协议），可以允许任何类型的对象或代码，在任何平台上，以任何一种语言相互通信。这种相互通信采用的是XML格式的消息。</span><br><span class="line"></span><br><span class="line"><span class="comment">### C#中 property 与 attribute的区别，他们各有什么用处，这种机制的好处在哪里？</span></span><br><span class="line"></span><br><span class="line">Attribute是Microsoft .NET Framework文件的元数据，可以用来向运行时描述你的代码，或者在程序运行的时候影响应用程序的行为。Attribute是派生于System.Attribute类之下，它的主要作用是描述</span><br><span class="line">Property是面向对象编程的基本概念，提供了对私有字段的访问封装，在C<span class="comment">#中以get和set访问器方法实现对可读可写属性的操作，提供了安全和灵活的数据访问封装。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### XML 与 HTML 的主要区别</span></span><br><span class="line"></span><br><span class="line">XML是HTML的补充，而不是HTML的替代品，XML和HTML是两种不同用途的语言。</span><br><span class="line">XML是被设计用来描述数据的，重点是：什么是数据，如何存放数据。而HTML是被设计用来显示数据的，重点是：显示数据以及如何显示数据更好上面。</span><br><span class="line">XML是自由的、可以扩展的,XML标记并不是预先规定好的，你必须创造你自XML标记并不是，而在HTML文档中必须使用规则中定义好的标记</span><br><span class="line">XML是区分大小写字母的，HTML不区分。</span><br><span class="line">在HTML中，如果上下文清楚地显示出段落或者列表键在何处结尾，那么你可以省略&lt;/p&gt;或者&lt;/li&gt;之类的结束 标记。在XML中，绝对不能省略掉结束标记。</span><br><span class="line">在XML中，拥有单个标记而没有匹配的结束标记的元素必须用一个 / 字符作为结尾。这样分析器就知道不用 查找结束标记了。</span><br><span class="line">在XML中，属性值必须封装在引号中。在HTML中，引号是可用可不用的。</span><br><span class="line">在HTML中，可以拥有不带值的属性名。在XML中，所有的属性都必须带有相应的值。</span><br><span class="line"></span><br><span class="line"><span class="comment">### c#中的三元运算符是？</span></span><br><span class="line"></span><br><span class="line">？：</span><br><span class="line"></span><br><span class="line"><span class="comment">### 当整数a赋值给一个object对像时，整数a将会被？</span></span><br><span class="line"></span><br><span class="line">装箱。</span><br><span class="line"></span><br><span class="line"><span class="comment">### 类成员有5种可访问形式？</span></span><br><span class="line"></span><br><span class="line">public</span><br><span class="line">private</span><br><span class="line">protected</span><br><span class="line">internal </span><br><span class="line">protected internal</span><br><span class="line"></span><br><span class="line"><span class="comment">### public static const int A=1;这段代码有错误么？是什么？</span></span><br><span class="line"></span><br><span class="line">const表现的很像静态变量，它们对类的每个实例都是可见的，而且即使没有类的实例它们也可以使用，而与静态变量不同的是它没有自己的存储位置，而是在编译时被编译器替换，因此它不能声明为Static。</span><br><span class="line"></span><br><span class="line"><span class="comment">### float f=-123.567F; int i=(int)f;i的值现在是 </span></span><br><span class="line">-123  </span><br><span class="line">将f的值强制转换成int型，也就是将小数点后面的部分直接截取，保留整数部分。</span><br><span class="line"></span><br><span class="line"><span class="comment">### 委托声明的关键字是 </span></span><br><span class="line">Delegate。 </span><br><span class="line"></span><br><span class="line"><span class="comment">### 在Asp.net中所有的自定义用户控件都必须继承自 </span></span><br><span class="line">Control。</span><br><span class="line"></span><br><span class="line"><span class="comment">### 在.Net中所有可序列化的类都被标记为 </span></span><br><span class="line">[Serializable]。</span><br><span class="line"></span><br><span class="line"><span class="comment">### 在.Net托管代码中我们不用担心内存漏洞,这是因为?</span></span><br><span class="line">有GC垃圾回收机制。</span><br><span class="line"></span><br><span class="line"><span class="comment">### 下面的代码中有什么错误吗？_______</span></span><br><span class="line">```bash</span><br><span class="line">using System;</span><br><span class="line"></span><br><span class="line">class A</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">public virtual void <span class="function"><span class="title">F</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;A.F&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract class B:A</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">public abstract override void F();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>abstract override 是不可以一起修饰.</p>
<h3 id="当类T只声明了私有实例构造函数时，则在T的程序文本外部，不可以从T派生出新的类？"><a href="#当类T只声明了私有实例构造函数时，则在T的程序文本外部，不可以从T派生出新的类？" class="headerlink" title="当类T只声明了私有实例构造函数时，则在T的程序文本外部，不可以从T派生出新的类？"></a>当类T只声明了私有实例构造函数时，则在T的程序文本外部，不可以从T派生出新的类？</h3><p>因为子类无法调用父类的构造函数，不可以直接创建T的任何实例。</p>
<h3 id="Switch语句的格式"><a href="#Switch语句的格式" class="headerlink" title="Switch语句的格式?"></a>Switch语句的格式?</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">switch (1 + 1)</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> 1:</span><br><span class="line"></span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;Wrong&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> 2:</span><br><span class="line"></span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;right&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line"></span><br><span class="line">                default:</span><br><span class="line"></span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;jiaoyanqing&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h3 id="在-Net中，类System-Web-UI-Page-可以被继承么？"><a href="#在-Net中，类System-Web-UI-Page-可以被继承么？" class="headerlink" title="在.Net中，类System.Web.UI.Page 可以被继承么？"></a>在.Net中，类System.Web.UI.Page 可以被继承么？</h3><p>可以。</p>
<h3 id="net的错误处理机制是什么？"><a href="#net的错误处理机制是什么？" class="headerlink" title=".net的错误处理机制是什么？"></a>.net的错误处理机制是什么？</h3><p>.net错误处理机制采用try-&gt;catch-&gt;finally结构，发生错误时，层层上抛，直到找到匹配的Catch为止。</p>
<p>异常：它是程序中的运行时错误，它违反了一个系统约束或应用程序约束，或出现了在正常操作时未预料的情形，如果程序没有提供处理该异常的代码，系统会挂起这个程序。</p>
<p>即使在Try块中有Return语句，Finally块也总是会在返回到调用代码之前执行。</p>
<h3 id="利用operator声明且仅声明了-x3D-x3D-，有什么错误么"><a href="#利用operator声明且仅声明了-x3D-x3D-，有什么错误么" class="headerlink" title="利用operator声明且仅声明了&#x3D;&#x3D;，有什么错误么?"></a>利用operator声明且仅声明了&#x3D;&#x3D;，有什么错误么?</h3><p>要同时修改Equale和GetHash() ? 重载了”&#x3D;&#x3D;” 就必须重载 “!&#x3D;” </p>
<h3 id="62-63-x3D-1-等式不成立，请移动一个数字（不可以移动减号和等于号），使得等式成立，如何移动？"><a href="#62-63-x3D-1-等式不成立，请移动一个数字（不可以移动减号和等于号），使得等式成立，如何移动？" class="headerlink" title="62-63&#x3D;1 等式不成立，请移动一个数字（不可以移动减号和等于号），使得等式成立，如何移动？"></a>62-63&#x3D;1 等式不成立，请移动一个数字（不可以移动减号和等于号），使得等式成立，如何移动？</h3><p>62移动成2的6次方</p>
<h3 id="对于这样的一个枚举类型：enum-Color-byte-Red-Green-Blue-Orange"><a href="#对于这样的一个枚举类型：enum-Color-byte-Red-Green-Blue-Orange" class="headerlink" title="对于这样的一个枚举类型：enum Color : byte { Red, Green, Blue, Orange };"></a>对于这样的一个枚举类型：enum Color : byte { Red, Green, Blue, Orange };</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string[] ss = Enum.GetNames(typeof(Color));</span><br><span class="line"></span><br><span class="line">Array array = Enum.GetValues(typeof(Color));</span><br></pre></td></tr></table></figure>

<h3 id="C-可否对内存进行直接的操作？"><a href="#C-可否对内存进行直接的操作？" class="headerlink" title="C#可否对内存进行直接的操作？"></a>C#可否对内存进行直接的操作？</h3><p>C#可以直接对内存进行操作。但是默认情况下，为了保持类型安全，C#不支持指针运算。不过，通过使用 unsafe 关键字，可以定义可使用指针的不安全上下文。在不安全的上下文中，类型可以是指针类型以及值类型或引用类型。</p>
<h3 id="ADO-NET相对于ADO等主要有什么改进？"><a href="#ADO-NET相对于ADO等主要有什么改进？" class="headerlink" title="ADO.NET相对于ADO等主要有什么改进？"></a>ADO.NET相对于ADO等主要有什么改进？</h3><p>ADO.NET不依赖于数据提供程序,而是使用.Net托管提供的程序。<br>不使用com<br>不在支持动态游标和服务器端游<br>可以断开connection而保留当前数据集可用<br>强类型转换<br>xml支持</p>
<h3 id="大概描述一下ASP-NET服务器控件的生命周期"><a href="#大概描述一下ASP-NET服务器控件的生命周期" class="headerlink" title="大概描述一下ASP.NET服务器控件的生命周期"></a>大概描述一下ASP.NET服务器控件的生命周期</h3><p>初始化 加载视图状态 处理回发数据 加载 发送回发更改通知 处理回发事件 预呈现 保存状态 呈现 处置 卸载</p>
<h3 id="匿名内部类是否可以继承其它类，是否可以实现接口"><a href="#匿名内部类是否可以继承其它类，是否可以实现接口" class="headerlink" title="匿名内部类是否可以继承其它类，是否可以实现接口?"></a>匿名内部类是否可以继承其它类，是否可以实现接口?</h3><p>不能，可以实现接口</p>
<h3 id="amp-和-amp-amp-的区别。"><a href="#amp-和-amp-amp-的区别。" class="headerlink" title="&amp;和&amp;&amp;的区别。"></a>&amp;和&amp;&amp;的区别。</h3><p>&amp;是位运算符，表示按位与运算，&amp;&amp;是逻辑运算符，表示逻辑与（and）.</p>
<h3 id="HashMap和Hashtable的区别。"><a href="#HashMap和Hashtable的区别。" class="headerlink" title="HashMap和Hashtable的区别。"></a>HashMap和Hashtable的区别。</h3><p>HashMap是Hashtable的轻量级实现（非线程安全的实现），他们都完成了Map接口，主要区别在于HashMap允许空（null）键值（key）,由于非线程安全，效率上可能高于Hashtable.</p>
<h3 id="重载方法可以改变返回值的类型"><a href="#重载方法可以改变返回值的类型" class="headerlink" title="重载方法可以改变返回值的类型?"></a>重载方法可以改变返回值的类型?</h3><h3 id="error和exception有什么区别"><a href="#error和exception有什么区别" class="headerlink" title="error和exception有什么区别?"></a>error和exception有什么区别?</h3><p>error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况。</p>
<p>exception 表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况。</p>
<h3 id="lt-gt-和-lt-gt-有什么区别？"><a href="#lt-gt-和-lt-gt-有什么区别？" class="headerlink" title="&lt;%# %&gt; 和 &lt;% %&gt; 有什么区别？"></a>&lt;%# %&gt; 和 &lt;% %&gt; 有什么区别？</h3><p>&lt;%# %&gt;表示绑定的数据源</p>
<p>&lt;% %&gt;是服务器端代码块</p>
<h3 id="重载与覆盖的区别？"><a href="#重载与覆盖的区别？" class="headerlink" title="重载与覆盖的区别？"></a>重载与覆盖的区别？</h3><p>方法的覆盖是子类和父类之间的关系，是垂直关系；方法的重载是同一个类中方法之间的关系，是水平关系<br>覆盖是一个方法或一对方法产生关系；方法的重载是多个方法之间的关系。<br>覆盖要求参数列表相同；重载要求参数列表不同。<br>覆盖关系中，调用那个方法体，是根据对象的类型（对象对应存储空间类型）来决定；重载关系，是根据调用时的实参表与形参表来选择方法体的。</p>
<h3 id="分析以下代码。"><a href="#分析以下代码。" class="headerlink" title="分析以下代码。"></a>分析以下代码。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public static void <span class="built_in">test</span>(string ConnectString)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">System.Data.OleDb.OleDbConnection conn = new System.Data.OleDb.OleDbConnection();</span><br><span class="line"></span><br><span class="line">conn.ConnectionString = ConnectString;</span><br><span class="line"></span><br><span class="line">try</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">conn.Open();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">catch(Exception Ex)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">MessageBox.Show(Ex.ToString());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">finally</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!conn.State.Equals(ConnectionState.Closed))</span><br><span class="line"></span><br><span class="line">conn.Close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请问</p>
<ol>
<li>以上代码可以正确使用连接池吗？</li>
</ol>
<p>如果传入的connectionString是一模一样的话，可以正确使用连接池。不过一模一样的意思是，连字符的空格数，顺序完全一致。</p>
<h3 id="什么是WSE？目前最新的版本是多少？"><a href="#什么是WSE？目前最新的版本是多少？" class="headerlink" title="什么是WSE？目前最新的版本是多少？"></a>什么是WSE？目前最新的版本是多少？</h3><p>WSE (Web Service Extension) 包来提供最新的WEB服务安全保证，目前最新版本2.0。</p>
<h3 id="下面的例子中"><a href="#下面的例子中" class="headerlink" title="下面的例子中"></a>下面的例子中</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        public static int X;</span><br><span class="line"></span><br><span class="line">        static <span class="function"><span class="title">A</span></span>()</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            X = B.Y + 1;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class B</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        public static int Y = A.X + 1;</span><br><span class="line"></span><br><span class="line">        static <span class="function"><span class="title">B</span></span>() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">static void <span class="function"><span class="title">Main</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;X=&#123;0&#125;,Y=&#123;1&#125;&quot;</span>, mytest.A.X, mytest.B.Y);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>产生的输出结果是什么？</p>
<p>X&#x3D;2,Y&#x3D;1; </p>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h3><blockquote><p>反射是 .net framework 提供的一个帮助类库，用于读取和使用元数据。<br>程序集包含模块，而模块包含类型，类型又包含成员。反射则是访问封装程序集，模块和类型的对象的方法。<br>您可以使用反射动态的创建类型的实例，将类型绑定到现有对象，或从现有对象中获取类型<br>然后可以调用类型其方法或访问其字段和属性（注意：无法访问私有构造）。</p>
</blockquote>
<p>简单的说就是反射可以看清一个类或者说对象的本质<br>可以了解一个类或者说对象其底下有多少个方法，多少个属性，多少个私有属性，<br>并对其操作调用。</p>
<h3 id="用到的类："><a href="#用到的类：" class="headerlink" title="用到的类："></a>用到的类：</h3><blockquote><p>1）System.Reflection（其中System.Reflection.Assembly.LoadFile&#x3D;&gt;用于动态的加载程序集）<br>2）System.Type<br>System.Type 类对于反射起着核心的作用。 当反射请求加载的类型时，公共语言运行时将为它创建一个 Type。<br>您可以使用 Type 对象的方法、字段、属性和嵌套类来查找有关该类型的所有信息。</p>
</blockquote>

<h3 id="反射优缺点"><a href="#反射优缺点" class="headerlink" title="反射优缺点"></a>反射优缺点</h3><blockquote><p>优点：</p>
<p>1、反射提高了程序的灵活性和扩展性。<br>2、降低耦合性，提高自适应能力。<br>3、它允许程序创建和控制任何类的对象，无需提前硬编码目标类。<br>缺点：</p>
<p>1、性能问题：使用反射基本上是一种解释操作，用于字段和方法接入时要远慢于直接代码。因此反射机制主要应用在对灵活性和拓展性要求很高的系统框架上，普通程序不建议使用。<br>2、使用反射会模糊程序内部逻辑；程序员希望在源代码中看到程序的逻辑，反射却绕过了源代码的技术，因而会带来维护的问题，反射代码比相应的直接代码更复杂。</p>
</blockquote>
<h3 id="反射的用途"><a href="#反射的用途" class="headerlink" title="反射的用途"></a>反射的用途</h3><blockquote><p>1、它允许在运行时查看特性（attribute）信息。<br>2、它允许审查集合中的各种类型，以及实例化这些类型。<br>3、它允许延迟绑定的方法和属性（property）。<br>4、它允许在运行时创建新类型，然后使用这些类型执行一些任务。<br>5、MVC的路由就是反射做的。访问的Global的时候，会加载一遍dll</p>
</blockquote>

<h3 id="查看元数据"><a href="#查看元数据" class="headerlink" title="查看元数据"></a>查看元数据</h3><p>1、获取当前实例的 System.Type 的两种方式<br>1）使用对象 GetType()方法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Rectangle nc = new Rectangle();</span><br><span class="line">Type <span class="built_in">type</span> = nc.GetType();</span><br></pre></td></tr></table></figure>
<p>2）使用c# typeof 运算符</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type <span class="built_in">type</span> = typeof(Rectangle);</span><br></pre></td></tr></table></figure>
<p>2、查看类中的成员：GetMembers()</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MemberInfo[] minfos = type.GetMembers();</span><br><span class="line">foreach (var i <span class="keyword">in</span> minfos)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;成员: &#123;0&#125;&quot;</span>, i.Name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、查看类中的构造方法：GetConstructors()</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ConstructorInfo[] ci = type.GetConstructors();</span><br><span class="line">foreach (var i <span class="keyword">in</span> ci)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;构造函数: &#123;0&#125;&quot;</span>, i.Name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、查看类中的属性：GetProperties()</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PropertyInfo[] pis = type.GetProperties();</span><br><span class="line">foreach (var i <span class="keyword">in</span> pis)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;属性: &#123;0&#125;&quot;</span>, i.Name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5、查看类中的字段：GetFields()</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FieldInfo[] fis = type.GetFields();</span><br><span class="line">foreach (var i <span class="keyword">in</span> fis)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;字段: &#123;0&#125;&quot;</span>, i.Name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6、用反射生成对象，并调用属性、方法和字段进行操作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">object obj = Activator.CreateInstance(<span class="built_in">type</span>);// 创建实例</span><br><span class="line">FieldInfo <span class="keyword">fi</span> = type.GetField(<span class="string">&quot;hight&quot;</span>);// 取得hight字段</span><br><span class="line">fi.SetValue(obj, );// 给hight字段赋值</span><br><span class="line">PropertyInfo pi1 = type.GetProperty(<span class="string">&quot;length&quot;</span>);// 取得length属性</span><br><span class="line">pi1.SetValue(obj, , null);// 给length属性赋值</span><br><span class="line">PropertyInfo pi2 = type.GetProperty(<span class="string">&quot;width&quot;</span>);// 取得width属性</span><br><span class="line">pi2.SetValue(obj, , null);// 给width属性赋值</span><br><span class="line">MethodInfo mi = type.GetMethod(<span class="string">&quot;GetVolume&quot;</span>);// 取得GetVolume方法</span><br><span class="line">mi.Invoke(obj, null);// 调用GetVolume方法</span><br></pre></td></tr></table></figure>
<p>7、查看类中的特性：type.GetCustomAttributes()</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Object[] attributes = type.GetCustomAttributes(<span class="literal">false</span>);</span><br><span class="line">foreach (var i <span class="keyword">in</span> attributes)</span><br><span class="line">&#123;</span><br><span class="line">    DeBugInfo dbi = i as DeBugInfo;</span><br><span class="line">    <span class="keyword">if</span> (null != dbi)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Bug no: &#123;0&#125;, Message: &#123;1&#125;&quot;</span>, dbi.BugNo, dbi.Message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Reflection;</span><br><span class="line">namespace ConsoleTest</span><br><span class="line">&#123;</span><br><span class="line">    // 一个自定义特性 BugFix 被赋给类及其成员</span><br><span class="line">    [AttributeUsage(AttributeTargets.Class |</span><br><span class="line">    AttributeTargets.Constructor |</span><br><span class="line">    AttributeTargets.Field |</span><br><span class="line">    AttributeTargets.Method |</span><br><span class="line">    AttributeTargets.Property,</span><br><span class="line">    AllowMultiple = <span class="literal">true</span>)]</span><br><span class="line"> </span><br><span class="line">    public class DeBugInfo : System.Attribute</span><br><span class="line">    &#123;</span><br><span class="line">        private int bugNo;</span><br><span class="line">        public string message;</span><br><span class="line"> </span><br><span class="line">        public DeBugInfo(int <span class="built_in">bg</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            this.bugNo = <span class="built_in">bg</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        public int BugNo</span><br><span class="line">        &#123;</span><br><span class="line">            get</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">return</span> bugNo;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public string Message</span><br><span class="line">        &#123;</span><br><span class="line">            get</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">return</span> message;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">set</span></span><br><span class="line">            &#123;</span><br><span class="line">                message = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 矩形</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    [DeBugInfo(, Message = <span class="string">&quot;Return type mismatch&quot;</span>)]</span><br><span class="line">    [DeBugInfo(, Message = <span class="string">&quot;Unused variable&quot;</span>)]</span><br><span class="line">    public class Rectangle</span><br><span class="line">    &#123;</span><br><span class="line">        public int hight = ;</span><br><span class="line">        public double length &#123; get; <span class="built_in">set</span>; &#125;</span><br><span class="line">        public double width &#123; get; <span class="built_in">set</span>; &#125;</span><br><span class="line">        public <span class="function"><span class="title">Rectangle</span></span>()</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        public Rectangle(double l, double w)</span><br><span class="line">        &#123;</span><br><span class="line">            length = l;</span><br><span class="line">            width = w;</span><br><span class="line">        &#125;</span><br><span class="line">        // 计算面积</span><br><span class="line">        [DeBugInfo(, Message = <span class="string">&quot;Return type mismatch&quot;</span>)]</span><br><span class="line">        public void <span class="function"><span class="title">GetArea</span></span>()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;面积: &#123;0&#125;&quot;</span>, length * width);</span><br><span class="line">        &#125;</span><br><span class="line">        //计算体积</span><br><span class="line">        [DeBugInfo()]</span><br><span class="line">        public void <span class="function"><span class="title">GetVolume</span></span>()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;体积: &#123;0&#125;&quot;</span>, length * width * hight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    class ExecuteRectangle</span><br><span class="line">    &#123;</span><br><span class="line">        public static void <span class="function"><span class="title">Main12</span></span>()</span><br><span class="line">        &#123;</span><br><span class="line">            //使用对象GetType()方法</span><br><span class="line">            //Rectangle nc = new Rectangle();</span><br><span class="line">            //Type <span class="built_in">type</span> = nc.GetType();</span><br><span class="line"> </span><br><span class="line">            //使用 C<span class="comment"># typeof 运算符</span></span><br><span class="line">            Type <span class="built_in">type</span> = typeof(Rectangle);</span><br><span class="line"> </span><br><span class="line">            // 获取 Rectangle 类的所有成员</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;\n遍历 Rectangle 类的成员开始---------------&quot;</span>);</span><br><span class="line">            MemberInfo[] minfos = type.GetMembers();</span><br><span class="line">            foreach (var i <span class="keyword">in</span> minfos)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;成员: &#123;0&#125;&quot;</span>, i.Name);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;-------------------结束-------------------&quot;</span>);</span><br><span class="line"> </span><br><span class="line">            // 获取 Rectangle 类的所有构造函数</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;\n遍历 Rectangle 类的构造函数开始-----------&quot;</span>);</span><br><span class="line">            ConstructorInfo[] ci = type.GetConstructors();</span><br><span class="line">            foreach (var i <span class="keyword">in</span> ci)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;构造函数: &#123;0&#125;&quot;</span>, i.Name);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;-------------------结束-------------------&quot;</span>);</span><br><span class="line"> </span><br><span class="line">            // 获取 Rectangle 类的所有属性</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;\n遍历 Rectangle 类的属性开始---------------&quot;</span>);</span><br><span class="line">            PropertyInfo[] pis = type.GetProperties();</span><br><span class="line">            foreach (var i <span class="keyword">in</span> pis)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;属性: &#123;0&#125;&quot;</span>, i.Name);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;-------------------结束-------------------&quot;</span>);</span><br><span class="line"> </span><br><span class="line">            // 获取 Rectangle 类的所有public字段</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;\n遍历 Rectangle 类的字段开始---------------&quot;</span>);</span><br><span class="line">            FieldInfo[] fis = type.GetFields();</span><br><span class="line">            foreach (var i <span class="keyword">in</span> fis)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;字段: &#123;0&#125;&quot;</span>, i.Name);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;-------------------结束-------------------&quot;</span>);</span><br><span class="line"> </span><br><span class="line">            //用反射生成对象，并调用属性、方法和字段进行操作</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;\n用反射生成对象，并调用属性、方法和字段进行操作&quot;</span>);</span><br><span class="line">            object obj = Activator.CreateInstance(<span class="built_in">type</span>);// 创建实例</span><br><span class="line">            FieldInfo <span class="keyword">fi</span> = type.GetField(<span class="string">&quot;hight&quot;</span>);// 取得hight字段</span><br><span class="line">            fi.SetValue(obj, );// 给hight字段赋值</span><br><span class="line">            PropertyInfo pi1 = type.GetProperty(<span class="string">&quot;length&quot;</span>);// 取得length属性</span><br><span class="line">            pi1.SetValue(obj, , null);// 给length属性赋值</span><br><span class="line">            PropertyInfo pi2 = type.GetProperty(<span class="string">&quot;width&quot;</span>);// 取得width属性</span><br><span class="line">            pi2.SetValue(obj, , null);// 给width属性赋值</span><br><span class="line">            MethodInfo mi = type.GetMethod(<span class="string">&quot;GetVolume&quot;</span>);// 取得GetVolume方法</span><br><span class="line">            mi.Invoke(obj, null);// 调用GetVolume方法</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;-------------------结束-------------------&quot;</span>);</span><br><span class="line"> </span><br><span class="line">            // 遍历 Rectangle 类的特性</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;\n遍历 Rectangle 类的特性开始---------------&quot;</span>);</span><br><span class="line">            Object[] attributes = type.GetCustomAttributes(<span class="literal">false</span>);</span><br><span class="line">            foreach (var i <span class="keyword">in</span> attributes)</span><br><span class="line">            &#123;</span><br><span class="line">                DeBugInfo dbi = i as DeBugInfo;</span><br><span class="line">                <span class="keyword">if</span> (null != dbi)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;Bug no: &#123;0&#125;, Message: &#123;1&#125;&quot;</span>, dbi.BugNo, dbi.Message);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;-------------------结束-------------------&quot;</span>);</span><br><span class="line"> </span><br><span class="line">            // 遍历 Rectangle 类的方法上的特性(此处只遍历)</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;\n遍历 Rectangle 类的方法上的特性开始-------&quot;</span>);</span><br><span class="line">            MethodInfo[] m = type.GetMethods(BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Public | BindingFlags.DeclaredOnly);</span><br><span class="line">            foreach (var i <span class="keyword">in</span> m )</span><br><span class="line">            &#123;</span><br><span class="line">                foreach (Attribute a <span class="keyword">in</span> i.GetCustomAttributes(<span class="literal">true</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    DeBugInfo dbi = a as DeBugInfo;</span><br><span class="line">                    <span class="keyword">if</span> (null != dbi)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Console.WriteLine(<span class="string">&quot;Bug no: &#123;0&#125;, for Method: &#123;1&#125;, Message: &#123;2&#125;&quot;</span>, dbi.BugNo, i.Name, dbi.Message);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;-------------------结束-------------------&quot;</span>);</span><br><span class="line"> </span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h2 id="System-Reflection-Assembly类"><a href="#System-Reflection-Assembly类" class="headerlink" title="System.Reflection.Assembly类"></a>System.Reflection.Assembly类</h2><p>Assembly类可以获得程序集的信息，也可以动态的加载程序集，以及在程序集中查找类型信息，并创建该类型的实例。</p>
<p>使用Assembly类可以降低程序集之间的耦合，有利于软件结构的合理化。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//通过程序集名称返回Assembly对象</span><br><span class="line">Assembly ass = Assembly.Load(<span class="string">&quot;ConsoleTest&quot;</span>);</span><br><span class="line"> </span><br><span class="line">//通过DLL、EXE文件名称返回Assembly对象</span><br><span class="line">Assembly ass = Assembly.LoadFrom(<span class="string">&quot;ConsoleTest.exe&quot;</span>);</span><br><span class="line"> </span><br><span class="line">//通过Assembly获取程序集中类</span><br><span class="line">Type t = ass.GetType(<span class="string">&quot;ConsoleTest.Rectangle&quot;</span>);   //参数必须是类的全名</span><br><span class="line"> </span><br><span class="line">//通过Assembly获取程序集中所有的类</span><br><span class="line">Type[] types = ass.GetTypes();</span><br></pre></td></tr></table></figure>

<h2 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h2><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>通过封装对象的属性，实现对象的方法事件一次得到最终的对象。</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><blockquote><p>把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果不想被外界方法，我们大可不必提供方法给外界访问。<br>简单来说：对内私有，对外公有，用get和set进行封装，保护数据，隐藏功能。<br>特点：<br>（1）是面向对象编程的核心思想<br>（2）对象（类）是由属性、方法、事件封装而成<br>（3）保证类的内部数据结构的完整<br>（4）包含属性封装、行为封装、对象封装、命名空间封装、解决方案封装<br>（5）访问修饰符：设置类的成员的访问权限<br>    1)public(公开)：任何代码都可访问<br>    2)private(私有)：只能在当前类中访问<br>    3)protected(受保护的)：当前类以及所有子类可访问<br>    4)internal：同一程序集（命名空间）可访问<br>    5)protected internal&#x2F;internal protected：同意程序集或子类可访问</p>
</blockquote>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>子类继承父类的所有公用属性和方法</p>
<blockquote><p>1）子类继承父类的属性、构造、行为<br>2）父类有的子类不一定具有，子类有的父类也不一定具有<br>3）c#不支持多重继承，但是可以多重接口继承<br>4）关键字this:当前类自己，base:当前类的亲父类<br>5）实例化过程（对象创建过程，先调用最终父类的构造，然后依次往下调用到当前类）<br>6）析构过程（对象销毁的过程，从自己开始销毁直到最终父类）</p>
</blockquote>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态包含重载和重写</p>
<blockquote><p>重载（关键字OverLoad）：函数名相同，参数个数、类型不同的统称为重载。<br>优点：在不改变原来方法的基础上，新增功能。</p>
<p>重写（关键字Override）：子类对基类中的虚成员（虚方法、虚属性等）或抽象成员（抽象方法、抽象属性等）进行覆盖，重新实现。</p>
</blockquote>


<p>[<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/attributes/" title="" target="">特性</a>]</p>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>.net中创建多线程可以有四种方式：</p>
<blockquote><p>Thread类<br>委托<br>ThreadPool类<br>Task类</p>
</blockquote>
<h3 id="Thread类创建多线程"><a href="#Thread类创建多线程" class="headerlink" title="Thread类创建多线程"></a>Thread类创建多线程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">///</span><br><span class="line">/// Thread类启动</span><br><span class="line">///</span><br><span class="line">public static void <span class="function"><span class="title">Thread_Start</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">Thread thread = new Thread(new ParameterizedThreadStart(AddA));</span><br><span class="line">thread.Start(“Thread”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="委托方式创建多线程"><a href="#委托方式创建多线程" class="headerlink" title="委托方式创建多线程"></a>委托方式创建多线程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">delegate void Delegate_Add(Object stateInfo);</span><br><span class="line">///</span><br><span class="line">/// 委托方式启动</span><br><span class="line">///</span><br><span class="line">public static void <span class="function"><span class="title">Delegate_Start</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">Delegate_Add dele_add = AddA;</span><br><span class="line">dele_add.BeginInvoke(“Delegate”, null,null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ThreadPool类创建多线程"><a href="#ThreadPool类创建多线程" class="headerlink" title="ThreadPool类创建多线程"></a>ThreadPool类创建多线程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">///</span><br><span class="line">/// 线程池方式启动</span><br><span class="line">///</span><br><span class="line">public static void <span class="function"><span class="title">ThreadPool_Start</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">WaitCallback w = new WaitCallback(AddA);</span><br><span class="line">ThreadPool.QueueUserWorkItem(w,“ThreadPool”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Task类创建多线程"><a href="#Task类创建多线程" class="headerlink" title="Task类创建多线程"></a>Task类创建多线程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">///</span><br><span class="line">/// Task方式启动</span><br><span class="line">///</span><br><span class="line">public static void <span class="function"><span class="title">Task_Start</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">Action add_Action = AddA;</span><br><span class="line">Task task = new Task(add_Action, “Task”);</span><br><span class="line">task.Start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="IsBackground"><a href="#IsBackground" class="headerlink" title="IsBackground"></a>IsBackground</h3><blockquote><p>所有的多线程操作，必定有一个主线程;<br>主线程(ParentThread)与子线程(ChildThread)的生命周期也是相互作用的;<br>子线程中的IsBackground属性，决定了两类线程生命周期的依赖关系;<br>如果ChildThread.IsBackGround&#x3D;true，ParentThread结束时，ChildThread也会终止；<br>如果ChildThread.IsBackGround&#x3D;false，ParentThread必须等ChildThread终止后才会终止;</p>
</blockquote>
<p>对于这四种多线程方法，默认生成线程的IsBackGround有所不同：</p>
<blockquote><p>类型	        IsBackGround<br>Thread类	    false<br>委托	        true<br>ThreadPool类	true<br>Task类	        true</p>
</blockquote>
<h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public static int a;</span><br><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">MultiThreadDemo demo = new MultiThreadDemo();</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Main Thread ID:&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">MultiThreadTest();</span><br><span class="line"></span><br><span class="line">Thread.Sleep(10000);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;a:&quot;</span> + a);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Main thread exits.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">///</span><br><span class="line">/// 打印当前线程信息</span><br><span class="line">///</span><br><span class="line">public static void <span class="function"><span class="title">PrinctCurrentThreadInfo</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">var t = Thread.CurrentThread;</span><br><span class="line">Console.WriteLine(“Current Thread ID:” + t.ManagedThreadId);</span><br><span class="line">Console.WriteLine(“Is Back Ground:&#123;0&#125;”, t.IsBackground);</span><br><span class="line">Console.WriteLine(“Thread Priority:” + t.Priority.ToString());</span><br><span class="line">Console.WriteLine(“Thread State:” + t.ThreadState.ToString());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">///</span><br><span class="line">/// 测试方法</span><br><span class="line">///</span><br><span class="line">///</span><br><span class="line">public static void AddA(Object stateInfo)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;&#123;0,-20&#125; Thread ID:&#123;1&#125;&quot;</span>, stateInfo.ToString(), Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;IsBackground:&#123;0&#125;\n&quot;</span>, Thread.CurrentThread.IsBackground);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (a &lt; 10)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;&#123;0,-20&#125; Start :&#123;1&#125;&quot;</span>, stateInfo.ToString(), a);</span><br><span class="line">    Thread.Sleep(10);</span><br><span class="line">    a++;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;&#123;0,-20&#125; End   :&#123;1&#125;\n&quot;</span>, stateInfo.ToString(), a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;&#123;0,-20&#125; Thread ID:&#123;1&#125; Result:&#123;2&#125;&quot;</span>, stateInfo.ToString(), Thread.CurrentThread.ManagedThreadId, a);</span><br><span class="line"><span class="built_in">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">///</span><br><span class="line">/// 多线程测试</span><br><span class="line">///</span><br><span class="line">public static void <span class="function"><span class="title">MultiThreadTest</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">a = 0;</span><br><span class="line">Thread_Start();</span><br><span class="line">Delegate_Start();</span><br><span class="line">ThreadPool_Start();</span><br><span class="line">Task_Start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h2><h3 id="什么是委托？"><a href="#什么是委托？" class="headerlink" title="什么是委托？"></a>什么是委托？</h3><blockquote><p>A请求B帮A获取或者传递的行为被称为：委托<br>直接表现为：将一个方法作为另一个方法的参数；</p>
</blockquote>
<h3 id="委托的声明方法"><a href="#委托的声明方法" class="headerlink" title="委托的声明方法"></a>委托的声明方法</h3><blockquote><p>&#x2F;&#x2F;无返回值无参数委托的定义方法<br>public delegate void NoReturnPara();</p>
<p>&#x2F;&#x2F;无参数，无返回值方法：<br>public void DoNothing()<br>{<br>    &#x2F;&#x2F; 没有参数，没有返回值<br>}</p>
</blockquote>

<h3 id="给委托赋值的几种方式"><a href="#给委托赋值的几种方式" class="headerlink" title="给委托赋值的几种方式"></a>给委托赋值的几种方式</h3><blockquote><p>&#x2F;&#x2F;实例化委托，并传入方法<br>NoReturbNoPara noreturn &#x3D; new NoReturbNoPara(this.DoNothing);</p>
<p>&#x2F;&#x2F;LinqToObject<br>NoReturbNoPara noreturn &#x3D; () &#x3D;&gt; { };</p>
<p>&#x2F;&#x2F;直接赋值<br>NoReturbNoPara noreturn &#x3D; this.DoNothing;</p>
</blockquote>

<h3 id="调用委托的方法"><a href="#调用委托的方法" class="headerlink" title="调用委托的方法"></a>调用委托的方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">noreturn.Invoke()</span><br></pre></td></tr></table></figure>
<p>上面展示的是委托的基本定义与使用方法<br>现在实际B&#x2F;S项目中基本摒弃了这种写法，转而使用封装好的泛型委托来使用；</p>
<p>使用方法：</p>
<blockquote><p>&#x2F;&#x2F;无返回值，无参数委托，不需要单独声明<br>Action act &#x3D; this.DoNothing;<br>&#x2F;&#x2F;无返回值，有参数委托，参数类型为泛型<br>Action<string> act &#x3D; p &#x3D;&gt; { };<br>&#x2F;&#x2F;返回类型为string，参数类型为string的委托<br>Func&lt;string,string&gt; func &#x3D; p &#x3D;&gt; p;</p>
<p>&#x2F;&#x2F;返回类型为bool，参数类型为string的委托<br>Func&lt;string,bool&gt; func &#x3D; p &#x3D;&gt; p.Equals(‘’);</p>
</blockquote>

<p>下面写几个简单的demo演示一下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 扩展方法</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">public static class DelegateExtend</span><br><span class="line">&#123;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 模仿Linq的Where操作</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;typeparam name=<span class="string">&quot;T&quot;</span>&gt;&lt;/typeparam&gt;</span><br><span class="line">    /// &lt;param name=<span class="string">&quot;scoure&quot;</span>&gt;数据源&lt;/param&gt;</span><br><span class="line">    /// &lt;param name=<span class="string">&quot;func&quot;</span>&gt;委托（自定义bool条件）&lt;/param&gt;</span><br><span class="line">    /// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">    public static IEnumerable&lt;T&gt; ExtWhere&lt;T&gt;(this IEnumerable&lt;T&gt; scoure, Func&lt;T, bool&gt; func)</span><br><span class="line">    &#123;</span><br><span class="line">        //遍历数据源的数据</span><br><span class="line">        foreach (var item <span class="keyword">in</span> scoure)</span><br><span class="line">        &#123;</span><br><span class="line">            //请求委托完成条件的筛选返回bool</span><br><span class="line">            bool bResult = func(item);</span><br><span class="line">            //把通过筛选提交的数据源，返回出去</span><br><span class="line">            <span class="keyword">if</span> (bResult)</span><br><span class="line">            &#123;</span><br><span class="line">                yield <span class="built_in">return</span> item;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面来调用这个方法，看一下委托的具体使用方法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 实体模型</span><br><span class="line">public class Student</span><br><span class="line">&#123;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// ID</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public string Id &#123; get; <span class="built_in">set</span>; &#125;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 名称</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public string Name &#123; get; <span class="built_in">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//查询出所有数据</span><br><span class="line">IEnumerable&lt;Student&gt; student = sql.QueryList&lt;Student&gt;();</span><br><span class="line">//定义一个匿名方法，并赋值给委托</span><br><span class="line">Func&lt;Student, bool&gt; func = delegate(Student s)</span><br><span class="line">&#123;</span><br><span class="line">    //自定义代码逻辑，返回bool类型</span><br><span class="line">    <span class="built_in">return</span> s.Id.Equals(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//传入委托</span><br><span class="line">IEnumerable&lt;Student&gt; list = student.ExtWhere(func);</span><br><span class="line"></span><br><span class="line">//第二种方法，使用linq语法（自定义逻辑）</span><br><span class="line">IEnumerable&lt;Student&gt; list1 = student.ExtWhere(p =&gt; p.Id.Equals(<span class="string">&quot;1&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>上面就是一个简单但很常见的委托使用场景</p>
<p>从侧面理解一下这段代码，</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExtWhere 是我要做的一件事情，但这件事情里面我需要一个bool类型的返回结果，那么我委托func去帮我获取到这个bool类型的结果</span><br></pre></td></tr></table></figure>

<h3 id="委托的好处"><a href="#委托的好处" class="headerlink" title="委托的好处"></a>委托的好处</h3><blockquote><p>解耦：抽出自定义逻辑，保留相同的逻辑，使代码分离。<br>简化代码：自定义逻辑，避免相同逻辑的代码重复。</p>
</blockquote>

<h2 id="控制反转"><a href="#控制反转" class="headerlink" title="控制反转"></a>控制反转</h2><h3 id="1：类与类的依赖"><a href="#1：类与类的依赖" class="headerlink" title="1：类与类的依赖"></a>1：类与类的依赖</h3><p>依赖是面向对象中用来描述类与类之间一种关系的概念。两个相对独立的对象，当一个对象负责构造另一个对象的实例，或者依赖另一个对象的服务，这样的两个对象之间主要体现为依赖关系</p>
<h3 id="2：控制反转-IoC-Inverse-of-Control"><a href="#2：控制反转-IoC-Inverse-of-Control" class="headerlink" title="2：控制反转(IoC,Inverse of Control)"></a>2：控制反转(IoC,Inverse of Control)</h3><p>说反转则要先说“正转”，传统中，在程序中使用new关键字配合构造函数去创建一个对象，这就是程序主动的创建其所依赖对象，这就是“正转”。</p>
<p>调用者不自己创建被调用者对象，而交由第三方（容器）进行创建被调用者对象，这个过程称为控制反转（inversion of control，IOC）。</p>
<p>为什么要控制反转？控制反转是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度，便于扩展和后期维护。</p>
<p>IoC的核心思想：在需要对象实例的时候，不要总考虑自己通过 new 来创建对象，放下依赖对象的创建过程，而是把创建对象的工作交给别人来负责，这个别人我们通常称为 容器 (Container) 或者 服务提供者 (ServiceProvider)。</p>
<h3 id="3-依赖注入-DI-Dependedency-Injection"><a href="#3-依赖注入-DI-Dependedency-Injection" class="headerlink" title="3:依赖注入(DI,Dependedency Injection)"></a>3:依赖注入(DI,Dependedency Injection)</h3><p>实现控制反转的主要方式是依赖查找（Dependency Lookup,DL）和依赖注入(DI,Dependedency Injection，DI)。依赖注入是一种更可取的方式。</p>
<p>依赖注入具体是指：调用类 不主动创建依赖对象，而是使用容器来帮忙创建及注入依赖对象，这个过程就称为依赖注入（Dependency Injection，DI）</p>
<p>具体的说：Class A（调用类）中用到 Class B 类型的对象（依赖对象），通常情况下，我们在 Class A 中使用new关键字配合构造函数创建一个 Class B 的对象</p>
<p>但是，采用依赖注入技术之后， Class A只需要定义一个Class B类型的属性，不需要直接new来获得这个对象，而是通过IOC容器 将Class B类型的对象在外部new出来并注入到Class A里的引用中，从而实现Class A和Class B解耦。</p>
<h2 id="控制反转容器"><a href="#控制反转容器" class="headerlink" title="控制反转容器"></a>控制反转容器</h2><p>1：IoC容器</p>
<blockquote><p>在说到控制反转时提到“使用IOC容器在 调用类 外部创建 依赖对象 并注入到 调用类”，其中IOC容器是什么？</p>
<p>IOC容器就是具有依赖注入功能的容器，IOC容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。从而，应用程序无需直接在代码中new相关的对象，应用程序由IOC容器进行组装。</p>
<p>简而言之，IOC容器主要就两个作用：1、绑定服务与实例之间的关系；2、对实例进行创建和销毁。</p>
</blockquote>
<p>2：.NET最为流行的IoC容器框架</p>
<blockquote><p>Unity：微软patterns&amp;practicest团队开发的IOC依赖注入框架，支持AOP横切关注点。</p>
<p>MEF（Managed Extensibility Framework）：是一个用来扩展.NET应用程序的框架，可开发插件系统。</p>
<p>Spring.NET：依赖注入、面向方面编程(AOP)、数据访问抽象,、以及ASP.NET集成。</p>
<p>PostSharp：实现静态AOP横切关注点，使用简单，功能强大，对目标拦截的方法无需任何改动。</p>
<p>Autofac：最流行的依赖注入和IOC框架，轻量且高性能，对项目代码几乎无任何侵入性。</p>
</blockquote>

<h2 id="NET-依赖注入的集中方式"><a href="#NET-依赖注入的集中方式" class="headerlink" title=".NET 依赖注入的集中方式"></a>.NET 依赖注入的集中方式</h2><p>1、构造器注入<br>通过构造器进行依赖注入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">private IMyInterFace _myinterface;</span><br><span class="line"></span><br><span class="line">public MyClass (IMyInterFace myinterface)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">this._myinterface = myinterface;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、Setter注入</p>
<p>通过属性的访问器进行依赖注入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private IMyInterFace _myinterface;</span><br><span class="line"></span><br><span class="line">public IMyInterFace myinterface</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">get &#123; <span class="built_in">return</span> _myinterface; &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> &#123; _myinterface = value; &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、接口注入</p>
<p>通过接口实现依赖注入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public interface IMyInterFaceCace</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">IMyInterFace myinterfacce &#123; get; <span class="built_in">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyClass : IMyInterFaceCace</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">private IMyInterFace _myinterfacce;</span><br><span class="line"></span><br><span class="line">public IMyInterFace myinterfacce</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">get &#123; <span class="built_in">return</span> _myinterfacce; &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> &#123; _myinterfacce = value; &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外,通过特性、反射+配置文件、定义注入方法也可进行依赖注入,不多赘述</p>
<h2 id="TCPD、UDP协议"><a href="#TCPD、UDP协议" class="headerlink" title="TCPD、UDP协议"></a>TCPD、UDP协议</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3>  <blockquote><p>TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。在简化的计算机网络OSI模型中，它完成第四层传输层所指定的功能，UDP（用户数据包协议）是同一层内另一个重要的传输协议。</p>
<p>在因特网协议族中，TCP所在层位于IP层之上、应用层之下的中间层。不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是IP层不提供这样的流机制，而是提供不可靠的包交换。</p>
<p>UDP（User Datagram Protocol，用户数据报协议）是OSI参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，IETF RFC 768是UDP的正式规范。UDP在IP报文的协议号是17。
  </p>
</blockquote>
<p>TCP和UDP使用IP协议从一个网络传送数据包到另一个网络。把IP想像成一种高速公路，它允许其它协议在上面行驶并找到到其它电脑的出口。TCP和UDP是高速公路上的“卡车”，它们携带的货物就是像HTTP，文件传输协议FTP这样的协议等。 </p>
<h3 id="TCP和UDP的优缺点"><a href="#TCP和UDP的优缺点" class="headerlink" title="TCP和UDP的优缺点"></a>TCP和UDP的优缺点</h3><p>TCP<br>  <blockquote><p>优点：可靠、稳定。可靠体现在TCP在传输数据之前，会有三次握手来建立连接，而且在数据传输时，有确认、重传、滑动窗口、拥塞控制等机制，在数据传完后，还会断开连接用来节约系统资源。</p>
<p>缺点：慢，效率低，占用系统资源高，易被攻击。TCP在传递数据之前，要先建立连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、拥塞控制等都会消耗大量时间，而且要在每台设备上维护所有的传输连接，事实上，每个连接都会占用系统的CPU、内存等硬件资源。由于TCP存在确认机制和三次握手机制，这些会导致TCP容易被人利用，实现DOS、DDOS、CC等攻击。
  </p>
</blockquote><br>UDP<br>  <blockquote><p>优点：快，比TCP稍安全。UDP没有TCP的握手、确认、滑动窗口、重传、拥塞控制等机制，UDP是一个无状态的传输协议，所以它在传递数据时非常快。没有TCP的这些机制，UDP较TCP被攻击者利用的漏洞就要少一些。但UDP也是无法避免攻击的，比如UDP Flood攻击等。</p>
<p>缺点：不可靠，不稳定。因为UDP没有TCP那些可靠的机制，在数据传递时，如果网络质量不好，就会很容易丢包。
  </p>
</blockquote></p>
<h3 id="TCP和UDP的应用场景"><a href="#TCP和UDP的应用场景" class="headerlink" title="TCP和UDP的应用场景"></a>TCP和UDP的应用场景</h3><blockquote><p>TCP应用场景：<br>    1.当对网络通讯质量有要求时，比如整个数据要准确无误的传递给对方，<br>    2.用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。<br>    3.在日常生活中，常见使用TCP协议的应用，比如浏览器使用HTTP，Outlook使用POP、SMTP，QQ文件传输等。</p>
<p>UDP应用场景：<br>  1.面向数据报方式<br>  2.网络数据大多为短消息<br>  3.拥有大量Client<br>  4.对数据安全性无特殊要求<br>  5.网络负担非常重，但对响应速度要求高
  </p>
</blockquote>

<h3 id="linq、lambda、entity-framework之间的关系"><a href="#linq、lambda、entity-framework之间的关系" class="headerlink" title="linq、lambda、entity framework之间的关系"></a>linq、lambda、entity framework之间的关系</h3>  <blockquote><p>  lambda： 一种匿名委托的精简版写法，明显的标志是&#x3D;&gt;符号</p>
<p>entity framework（简称EF）： 微软访问数据库的最快捷最成熟的框架（ORM），在EF出现以前有SqlHelper、NHibernate等访问数据库的框架</p>
<p>Linq： .net 3.5以后的一种语法，使用它可以像用sql语句那样方面地查询内存、xml、数据库等，大大减少了for循环的数量和增加了可靠性</p>
<p>lambda与entity framework什么关系： 可以说没多大关系</p>
<p>lambda与linq什么关系：linq一般有两种等价写法，一是类似sql的from…where…select，一是arr.where().select()，后者就是lamda的写法，看上去更紧凑，但lambda只是linq可选的一种写法</p>
<p>linq与entity framework什么关系： 相辅相成的关系，linq可以查询内存、xml、数据库，用于查数据库的部分在微软的.net的实现就称为entity framework。EF在研发的时候就考虑到尽量使用linq的优势。linq是C#语法的一部分，但EF不是。</p>
<p>“Lambda 表达式”是一个匿名函数，它可以包含表达式和语句，并且可用于创建委托或表达式树类型。</p>
<p>LINQ是语言集成查询，它允许编写C#或者Visual Basic代码以查询数据库相同的方式操作内存数据。所以，Lambda 是实现LINQ查询的方式。</p>
<p>Linq是在.NET Framework 3.5 中出现的技术，所以在创建新项目的时候必须要选3.5或者更高版 本，否则无法使用。选择3.5或更高版本的.NET Framework之后，创建类文件中会自动包含System.Linq 的命名空间。
  </p>
</blockquote>

<h3 id="EF-Entity-Framework-是什么？"><a href="#EF-Entity-Framework-是什么？" class="headerlink" title="EF(Entity Framework)是什么？"></a>EF(Entity Framework)是什么？</h3><blockquote><p>实体框架EF是<a target="_blank" rel="noopener" href="http://ado.net中的一组支持开发面向数据的软件应用程序的技术,是微软的一个orm框架./">http://ADO.NET中的一组支持开发面向数据的软件应用程序的技术，是微软的一个ORM框架。</a></p>
<p>主要有三种方式：</p>
<p>Database FirstDatabase First”模式</p>
<p>我们称之为“数据库优先”，前提是你的应用已经有相应的数据库，你可以使用EF设计工具根据数据库生成数据数据类，你可以使用Visual Studio模型设计器修改这些模型之间对应关系。</p>
<p>Model FirstModel First我们称之为“模型优先”，这里的模型指的是“ADO.NET Entity Framework Data Model”，此时你的应用并没有设计相关数据库，在Visual Studio中我们通过设计对于的数据模型来生成数据库和数据类。</p>
<p>Code FirstCode First模式我们称之为“代码优先”模式，是从EF4.1开始新建加入的功能。</p>
<p>使用Code First模式进行EF开发时开发人员只需要编写对应的数据类（其实就是领域模型的实现过程），然后自动生成数据库。这样设计的好处在于我们可以针对概念模型进行所有数据操作而不必关心数据的存储关系，使我们可以更加自然的采用面向对象的方式进行面向数据的应用程序开发。</p>
</blockquote>
<h3 id="什么是ORM"><a href="#什么是ORM" class="headerlink" title="什么是ORM?"></a>什么是ORM?</h3><blockquote><p>ORM指的是面向对象的对象模型和关系型数据库的数据结构之间的互相转换。</p>
<p>(表实体跟表之间的相互转换)</p>
<p>ORM框架有很多，EF框架是ORM框架的其中一种，是实现了ORM思想的框架。</p>
<p>O&#x3D;&gt;表实体</p>
<p>M&#x3D;&gt;映射关系</p>
<p>R&#x3D;&gt;数据库.表</p>
<p>—&gt;详解</p>
</blockquote>
<h3 id="为什么用EF而不用原生的ADO-NET"><a href="#为什么用EF而不用原生的ADO-NET" class="headerlink" title="为什么用EF而不用原生的ADO.NET?"></a>为什么用EF而不用原生的ADO.NET?</h3><blockquote><p>1）.极大的提高开发效率:EF是微软自己的产品,开发中代码都是强类型的,</p>
<p>xiefl代码效率非常高,自动化程度非常高,命令式的编程.</p>
<p>2）.EF提供的模型设计器非常强大,不仅仅带来了设计数据库的革命,也附带来的自动化模型代码的</p>
<p>功能也极大的提高开发和架构设计的效率.</p>
<p>3）.EF跨数据支持的是ORM框架主要功能点之一,带来的是可以通过仅仅改变配置就可以做到跨数据库的能力</p>
</blockquote>
<h3 id="如何提高LINQ性能问题？"><a href="#如何提高LINQ性能问题？" class="headerlink" title="如何提高LINQ性能问题？"></a>如何提高LINQ性能问题？</h3><blockquote><p>提升从数据库中拿数据的速度，可以参考以下几种方法：</p>
<p>1).在数据库中的表中定义合适的索引和键</p>
<p>2).只获得你需要的列（使用ViewModel或者改进查询）和行（使用IQueryable）</p>
<p>3).尽可能使用一条查询而不是多条</p>
<p>4).只为了展示数据，而不进行后续修改时，可以使用AsNoTracking。它不会影响生成的SQL，但它可以令系统少维护很多数据，从而提高性能</p>
<p>5).使用Reshaper等工具，它可能会在你写出较差的代码时给出提醒</p>
</blockquote>

<h3 id="什么是IEnumerable？"><a href="#什么是IEnumerable？" class="headerlink" title="什么是IEnumerable？"></a>什么是IEnumerable？</h3><blockquote><p>IEnumerable及IEnumerable的泛型版本IEnumerable是一个接口，它只含有一个方法GetEnumerator。Enumerable这个静态类型含有很多扩展方法，其扩展的目标是IEnumerable。</p>
<p>实现了这个接口的类可以使用Foreach关键字进行迭代（迭代的意思是对于一个集合，可以逐一取出元素并遍历之）。实现这个接口必须实现方法GetEnumerator。</p>
</blockquote>

<h3 id="IEnumerable的缺点有哪些？"><a href="#IEnumerable的缺点有哪些？" class="headerlink" title="IEnumerable的缺点有哪些？"></a>IEnumerable的缺点有哪些？</h3><blockquote><p>IEnumerable功能有限，不能插入和删除。</p>
<p>访问IEnumerable只能通过迭代，不能使用索引器。迭代显然是非线程安全的，每次IEnumerable都会生成新的IEnumerator，从而形成多个互相不影响的迭代过程。</p>
<p>在迭代时，只能前进不能后退。新的迭代不会记得之前迭代后值的任何变化。</p>
</blockquote>
<h3 id="延迟执行-Lazy-Loading-是什么？"><a href="#延迟执行-Lazy-Loading-是什么？" class="headerlink" title="延迟执行 (Lazy Loading)是什么？"></a>延迟执行 (Lazy Loading)是什么？</h3><blockquote><p>大部分LINQ语句是在最终结果的第一个元素被访问的时候（即在foreach中调用MoveNext方法）才真正开始运算的，这个特点称为延迟执行。一般来说，返回另外一个序列（通常为IEnumerable或IQueryable）的操作，使用延迟执行，而返回单一值的运算，使用立即执行。</p>
<p>IEnumerable是延迟执行的，当没有触发执行时，就不会进行任何运算。Select方法不会触发LINQ的执行。一些触发的方式是：foreach循环，ToList，ToArray，ToDictionary方法等</p>
</blockquote>
<h3 id="LINQ可视化工具简单介绍一下？"><a href="#LINQ可视化工具简单介绍一下？" class="headerlink" title="LINQ可视化工具简单介绍一下？"></a>LINQ可视化工具简单介绍一下？</h3><blockquote><p>LINQPad工具是一个很好的LINQ查询可视化工具。它由Threading in C#和C# in a Nutshell的作者Albahari编写，完全免费。它的下载地址是<a target="_blank" rel="noopener" href="http://www.linqpad.net/">http://www.linqpad.net/</a></p>
<p>进入界面后，LINQPad可以连接到已经存在的数据库（不过就仅限微软的SQL Server系，如果要连接到其他类型的数据库则需要安装插件）。某种程度上可以代替SQL Management Studio，是使用SQL Management Studio作为数据库管理软件的码农的强力工具，可以用于调试和性能优化（通过改善编译后的SQL规模）。</p>
<p>LINQPad支持使用SQL或C#语句（点标记或查询表达式）进行查询。你也可以通过点击橙色圈内的各种不同格式，看到查询表达式的各种不同表达方式：</p>
<p>Lambda：查询表达式的Lambda表达式版本，</p>
<p>SQL：由编译器转化成的SQL，通常这是我们最关心的部分，</p>
<p>IL：IL语言</p>
</blockquote>
<h3 id="LINQ-to-Object和LINQ-to-SQL有何区别？"><a href="#LINQ-to-Object和LINQ-to-SQL有何区别？" class="headerlink" title="LINQ to Object和LINQ to SQL有何区别？"></a>LINQ to Object和LINQ to SQL有何区别？</h3><blockquote><p>LINQ to SQL可以将查询表达式转换为SQL语句，然后在数据库中执行。相比LINQ to Object，则是将查询表达式直接转化为Enumerable的一系列方法，最终在C#内部执行。LINQ to Object的数据源总是实现IEnumerable（所以不如叫做LINQ to IEnumerable），相对的，LINQ to SQL的数据源总是实现IQueryable并使用Queryable的扩展方法。</p>
<p>将查询表达式转换为SQL语句并不保证一定可以成功。</p>
</blockquote>
<h3 id="除了EF，列举出你知道的ORM框架？"><a href="#除了EF，列举出你知道的ORM框架？" class="headerlink" title="除了EF，列举出你知道的ORM框架？"></a>除了EF，列举出你知道的ORM框架？</h3><blockquote><p>dapper EntityFramework、 EJB、Hibernate、IBATIS、SqlSugar 、freesql</p>
</blockquote>
<h3 id="在哪些类型额项目中你会选择EF-为什么？"><a href="#在哪些类型额项目中你会选择EF-为什么？" class="headerlink" title="在哪些类型额项目中你会选择EF? 为什么？"></a>在哪些类型额项目中你会选择EF? 为什么？</h3><blockquote><p>这个要结合EF的特点来说：EF主要是以面向对象的思想来做数据库数据操作，对Sql语句能力没什么要求，开发使用效率高！便于上手，一般来说，使用EF框架，肯定会比直接使用ADO.NET，消耗的时间多一些。所以在一般企业级开发，管理型系统，对数据性能要求不是特别高的情况下，优先选择EF,这样可以大大的推进开发效率！如果像一些互联网项目中，对性能要求精度很高！可以另外做技术选型，选择原生ADO.NET。</p>
</blockquote>
<h3 id="请说明EF中映射实体对象的几种状态？"><a href="#请说明EF中映射实体对象的几种状态？" class="headerlink" title="请说明EF中映射实体对象的几种状态？"></a>请说明EF中映射实体对象的几种状态？</h3><blockquote><p>Detached：该实体未由上下文跟踪。刚使用新运算符或某个 System.Data.Entity.DbSet Create 方法创建实体后，实体就处于此状态。</p>
<p>Unchanged：实体将由上下文跟踪并存在于数据库中，其属性值与数据库中的值相同。</p>
<p>Added：实体将由上下文跟踪，但是在数据库中还不存在。</p>
<p>Deleted：实体将由上下文跟踪并存在于数据库中，但是已被标记为在下次调用 SaveChanges 时从数据库中删除。</p>
<p>Modified：实体将由上下文跟踪并存在于数据库中，已修改其中的一些或所有属性值。</p>
</blockquote>
			</div>

			<!-- recommended posts -->
			

			<div>
				<center>
					<div class="pagination">
<ul class="pagination">
	 
				
    	<li class="prev"><a href="/2023/02/08/dotnet5/" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i>上一页</a></li>
  		

        <li><a href="/archives"><i class="fa fa-archive"></i>档案</a></li>

		
		   <li class="next"><a href="/2023/02/02/dotnet3/" class="alignright next">下一页<i class="fa fa-arrow-circle-o-right"></i></a></li>         
        
	
</ul>
</div>

				</center>
			</div>

			<!-- share -->
			
			
    <div class="bdsharebuttonbox">
        <a href="#" class="bds_more" data-cmd="more"></a>
        <a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a>
        <a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
        <a href="#" class="bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
        <a href="#" class="bds_twi" data-cmd="twi" title="分享到Twitter"></a>
        <a href="#" class="bds_linkedin" data-cmd="linkedin" title="分享到linkedin"></a>
        <a href="#" class="bds_evernotecn" data-cmd="evernotecn" title="分享到印象笔记"></a>
        <a href="#" class="bds_youdao" data-cmd="youdao" title="分享到有道云笔记"></a>
        <a href="#" class="bds_copy" data-cmd="copy" title="分享到复制网址"></a>
    </div>
    <script>
        window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"1","bdSize":"24"},"share":{}};
        with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
    </script>


			

			

			<!-- comment -->
			

<!-- <section id="comment">
  <h2 class="title">留言</h2>
  
</section> -->



			
			<!-- 来必力City版安装代码 -->
<div id="lv-container" data-id="city" data-uid="MTAyMC81NzQwMS8zMzg2NQ==">
	<script type="text/javascript">
   (function(d, s) {
       var j, e = d.getElementsByTagName(s)[0];

       if (typeof LivereTower === 'function') { return; }

       j = d.createElement(s);
       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
       j.async = true;

       e.parentNode.insertBefore(j, e);
   })(document, 'script');
	</script>
<noscript> 为正常使用来必力评论功能请激活JavaScript</noscript>
</div>
<!-- City版安装代码已完成 -->
			
		</div> <!-- col-md-9/col-md-12 -->

		
		<div id="side_meta">
			<div class="col-md-3" id="post_meta"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2023-02-03 
	</div>
	

	<!-- categories -->
    
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#categorys"><i class="fa fa-folder"></i></a>	
    <ul id="categorys" class="tag_box list-unstyled collapse in">
          
  <li>
    <li><a href="/categories/IT/">IT<span>98</span></a></li>
  </li>

    </ul>
	</div>
	

	<!-- tags -->
	
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#tags"><i class="fa fa-tags"></i></a>		  
    <ul id="tags" class="tag_box list-unstyled collapse in">	  
	    
  <li><a href="/tags/Net/">.Net<span>9</span></a></li> <li><a href="/tags/c/">c#<span>10</span></a></li>
    </ul>
	</div>
	

	<!-- toc -->
	<div class="meta-widget">
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->

		</div>
		


	</div><!-- row -->


	
    
      <nav id="main-nav" class="navbar navbar-inverse navbar-default navbar-fixed-top"
  role="navigation">
  <div class="container">
    <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">月落星辰</a>
    <div class="collapse navbar-collapse nav-menu">
      <ul class="nav navbar-nav">
        
        <li>
          <a href="/archives" title="所有发表记录">
            <i class="fa fa-archive"></i>Archives
          </a>
        </li>
        
        <li>
          <a href="/note" title="我的速记">
            <i class="fa fa-user"></i>Note
          </a>
        </li>
        
        <li>
          <a href="/mark" title="mark清单">
            <i class="fa fa-list-ol"></i>Mark
          </a>
        </li>
        
        <li>
          <a href="/message" title="messagebord">
            <i class="fa fa-book"></i>Messagebord
          </a>
        </li>
        
        <li>
          <a href="/about" title="关于我">
            <i class="fa fa-user"></i>About
          </a>
        </li>
        

        <li>
          <div class="music-player">
            <iframe frameborder="no" border="0" marginwidth="0" marginheight="0"
              src="//music.163.com/outchain/player?type=0&id=8218805597&auto=0&height=66"></iframe>
        </li>
      </ul>
    </div>
  </div> <!-- container -->
</nav>
<div class="clearfix"></div>
      <div class="container-narrow">
        <footer> <a class="baurl" target="_blank;" href="https://beian.miit.gov.cn/">蜀ICP备2020030582号</a>
|

<!-- 不蒜子统计 -->
<span id="busuanzi_container_site_pv">
  浏览 <span id="busuanzi_value_site_pv"></span> 次
</span>
<span class="post-meta-divider">|</span>
<span id="busuanzi_container_site_uv" style='display:none'>
  访客 <span id="busuanzi_value_site_uv"></span> 人
</span>



<div class="distant_1"></div>

<p style="padding-bottom:3em;">
  &copy; 2023 南疆
  
  with help from <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/"
    target="_blank">Twitter Bootstrap</a>. Theme by <a target="_blank" rel="noopener" href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>.
</p> </footer>
      </div>
    </div>
  </div>
  <!-- <div class="container-narrow">
    <footer> <a class="baurl" target="_blank;" href="https://beian.miit.gov.cn/">蜀ICP备2020030582号</a>
|

<!-- 不蒜子统计 -->
<span id="busuanzi_container_site_pv">
  浏览 <span id="busuanzi_value_site_pv"></span> 次
</span>
<span class="post-meta-divider">|</span>
<span id="busuanzi_container_site_uv" style='display:none'>
  访客 <span id="busuanzi_value_site_uv"></span> 人
</span>



<div class="distant_1"></div>

<p style="padding-bottom:3em;">
  &copy; 2023 南疆
  
  with help from <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/"
    target="_blank">Twitter Bootstrap</a>. Theme by <a target="_blank" rel="noopener" href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>.
</p> </footer>
  </div> container-narrow -->

  



  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>


<!-- syntax highlighting -->



</body>

</html>